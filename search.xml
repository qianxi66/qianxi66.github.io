<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>蓝桥杯2020年题目思路</title>
    <url>/2023/04/06/2020/</url>
    <content><![CDATA[<h2 id="D七段码"><a href="#D七段码" class="headerlink" title="D七段码"></a>D七段码</h2><p>题目：<br><img src="/../someimage/asa.png"><br>注意两个三根棍相连地方对三根棍来说都算连接。难点：  </p>
<ol>
<li>将每个边抽象成一个点建图</li>
<li>枚举每个点亮不亮两种选择，共有2^7-1&#x3D;127种。将状态压缩为一个整数，每个灯亮不亮由0或1表示</li>
<li>判断每种组合是否联通：随便找一点dfs，用vis数组记录走过。最后遍历vis，若有为0的点则不连通</li>
</ol>
<span id="more"></span>  

<p>代码如下：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num,sum, q, cous, map[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">10</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuchu</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a%<span class="number">2</span>;</span><br><span class="line">		a/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[a] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">7</span>; j++)</span><br><span class="line">	&#123;<span class="comment">//儿子并且选出来并且没走过</span></span><br><span class="line">		<span class="keyword">if</span> (map[a][j] &amp;&amp; <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), j) != v.<span class="built_in">end</span>()&amp;&amp;!vis[j])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span> ,<span class="built_in">sizeof</span>(vis) );</span><br><span class="line">	q = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(v[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[v[i]] == <span class="number">0</span>)</span><br><span class="line">		q = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (q)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map[<span class="number">1</span>][<span class="number">2</span>] = map[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">1</span>][<span class="number">6</span>] = map[<span class="number">6</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">2</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">2</span>][<span class="number">3</span>]=map[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">4</span>] = map[<span class="number">4</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">4</span>][<span class="number">5</span>] = map[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">5</span>][<span class="number">6</span>]=map[<span class="number">6</span>][<span class="number">5</span>]=<span class="number">1</span>;</span><br><span class="line">map[<span class="number">5</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">6</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) - <span class="number">1</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">7</span>; m++)</span><br><span class="line">		<span class="keyword">if</span> (i &gt;&gt; m &amp; <span class="number">1</span>)</span><br><span class="line">			v.<span class="built_in">push_back</span>(m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">check</span>(i))</span><br><span class="line">	&#123;</span><br><span class="line">		sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	v.<span class="built_in">clear</span>();<span class="comment">//清空v</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;答案：&quot;</span> &lt;&lt; sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../someimage/wa.png"></p>
]]></content>
  </entry>
  <entry>
    <title>蒟蒻的蓝桥杯省赛之旅</title>
    <url>/2023/04/11/2023/</url>
    <content><![CDATA[<h2 id="A-幸运数"><a href="#A-幸运数" class="headerlink" title="A:幸运数"></a>A:幸运数</h2><p>题目大意：寻找<code>100000000</code>内的长度为偶数的，前面一半和等于后面一半的数<br>code：  </p>
<span id="more"></span>  


<pre><code class="cpp">
#include&lt;iostream&gt;
#include&lt;string&gt;//我忘了tostring在这个头文件里了！
using namespace std;
int num;
int main() &#123;
    int n = 100000000;
    for (int i = 1; i &lt; n; i++)
    &#123;
        string a = to_string(i);
        if (a.size() &amp; 1)continue;
        else &#123;
            int s = a.size() / 2;
            int s1=0, s2 = 0;
            for (int i = 0; i &lt; s; i++)
            &#123;
                s1 += a[i] - &#39;0&#39;;
            &#125;
            for (int i = s; i &lt; a.size(); i++)
            &#123;
                s2 += a[i] - &#39;0&#39;;
            &#125;
            if (s1 == s2) &#123;
                cout &lt;&lt; a &lt;&lt; endl;
                num++;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; &quot;答案是&quot;&lt;&lt;num;
&#125;
</code></pre>
<p>答案4430091。可是！！！！！这个破玩意活生生运行了6分钟！！！！我考场上还以为是devcpp的问题，结果回来拿vs一弄发现。。。怎么也这么慢。不过细细一想就知道了。。。因为这是个O(n2)的算法。。。  </p>
<h2 id="B：有奖问答"><a href="#B：有奖问答" class="headerlink" title="B：有奖问答"></a>B：有奖问答</h2><p>题目大意：一共30道题，答对一题加10分，答错分数清零。你攒够100分就可以拿到奖品退出游戏。现在做完所有题后，你一共拿了70分。请问对于你答对的题有几种可能性<br>思路：暴搜。。。到达100剪枝<br>我知道我哪错了……我dfs的时候答错没给分数清零……这波是审题问题啊啊啊啊我哭死  </p>
<h2 id="C：平方差"><a href="#C：平方差" class="headerlink" title="C：平方差"></a>C：平方差</h2><p>题目大意：输入区间l，r。请你查找区间中有哪些数可以写成x^2-y^2的形式<br>思路：暴力打表……不会…打了1000以内的表，应该能水30%的点？</p>
]]></content>
  </entry>
  <entry>
    <title>基于B树的图书管理系统</title>
    <url>/2023/05/26/btree/</url>
    <content><![CDATA[<h2 id="程序构思"><a href="#程序构思" class="headerlink" title="程序构思"></a>程序构思</h2><p>分为三个头文件：类头文件，函数实现头文件，源文件。源文件实现和用户的交互。<br>分为三个类：book btnode btree<br>分别存储  书对象  树节点  b树接口<br>一共六个操作：  </p>
<ol>
<li>采编入口  </li>
<li>清除库存  </li>
<li>借阅  </li>
<li>归还  </li>
<li>查询  </li>
<li>显示<br>每个操作两个函数，一个负责和b树的交互，一个和用户交互。</li>
</ol>
<span id="more"></span>  

<h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><ol>
<li>头文件源文件如何共享全局变量  </li>
<li>文件oi乱码</li>
<li>如何实现文件的更新</li>
<li>凹入表</li>
</ol>
<h3 id="头文件源文件如何共享全局变量"><a href="#头文件源文件如何共享全局变量" class="headerlink" title="头文件源文件如何共享全局变量"></a>头文件源文件如何共享全局变量</h3><p>用extern在头文件中声明变量，在cpp中定义（赋值）变量<br>本来想定义一个全局树对象，后来发现还是不行。。。就改传参了。类A中有两个函数a(),b()，a中调用b居然也要以对象.的形式，真麻烦。。。。</p>
<h3 id="文件oi乱码"><a href="#文件oi乱码" class="headerlink" title="文件oi乱码"></a>文件oi乱码</h3><p><img src="/../someimage/hao.png"><br>咱就是说电脑是GBK，但是文件是UTF-8，将文件编码改为ANSI就行了<br><img src="/../someimage/le.png"></p>
<h3 id="凹入表"><a href="#凹入表" class="headerlink" title="凹入表"></a>凹入表</h3><p>之前看网上的凹入表图片没有头绪，后来发现不过是树的先序遍历……打印孩子换行，根据层数记算每个孩子前面的空格  </p>
<pre><code class="cpp">
void travel(BTNodePosi a, int k)
&#123;
    if (a == NULL)return;//没有东西
    for (int cnt = 0; cnt &lt; k; cnt++)
        cout &lt;&lt; &quot;  &quot;;
    for (int i = 0; i &lt; a-&gt;key.size(); i++)
        if (i == 0)cout &lt;&lt; a-&gt;key[i];
        else cout &lt;&lt; &quot;,&quot; &lt;&lt; a-&gt;key[i];
    cout &lt;&lt; endl;
    for (int i = 0; i &lt; a-&gt;child.size(); i++)
        travel(a-&gt;child[i], k + 1);//下一层
&#125;
</code></pre>
<h2 id="写后感"><a href="#写后感" class="headerlink" title="写后感"></a>写后感</h2><p>这个程序最怪的是主函数中定义了一棵树，然后树类内部的操作函数还需要传树根的参，很诡异，也不知道哪里出了问题。因为借鉴的是c语言版，也不知道这个树实例化后怎么通过自己的函数直接改内部特性，好像可以this指针？<br>下了个大数据，4k本书调了一下，树没有问题，不过2-3树感觉没有用到b树过多的特性，速度方面应该还是挺慢的吧……</p>
]]></content>
  </entry>
  <entry>
    <title>关于起岸希的书单</title>
    <url>/2023/07/20/book/</url>
    <content><![CDATA[<p>众所周知，起岸希还是很爱读书的，她把她从大学一年级起读过的书整理了一下，有的没有读完，不过会努力更新进度  </p>
<h2 id="关于计算机"><a href="#关于计算机" class="headerlink" title="关于计算机"></a>关于计算机</h2><h3 id="c-primer-plus"><a href="#c-primer-plus" class="headerlink" title="c primer plus"></a>c primer plus</h3><span id="more"></span>    
<p><img src="/../someimage/cp.jpg"><br>我的c语言入门经典书~学校讲的稀烂，所有的计算机语言特性和c语言基础都是跟他学的，很厚，讲的很细致，很适合入门啃。我当时啃了两个月，期间的每一天都很快乐。  </p>
<h3 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h3><p><img src="/../someimage/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.jpg"><br>看了前2章，对整个计算机架构有个基本的了解，第三章数学比较多，含枯燥的公式论证</p>
<h3 id="算法竞赛入门经典"><a href="#算法竞赛入门经典" class="headerlink" title="算法竞赛入门经典"></a>算法竞赛入门经典</h3><p><img src="/../someimage/%E7%AE%97%E6%B3%95.jpg"><br>人称紫书，看了一半很有收获，感觉里面的oi类型较为古早，但是有很棒的思路，希望他能带我打进区域赛（  </p>
<h3 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h3><p><img src="/../someimage/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.jpg"><br>我看完的第一本算法书，也是我的算法入门书，全书小500页，讲的通俗易懂，知识点覆盖不全  </p>
<h3 id="网络是怎样连的"><a href="#网络是怎样连的" class="headerlink" title="网络是怎样连的"></a>网络是怎样连的</h3><p><img src="/../someimage/%E7%BD%91%E7%BB%9C.jpg"><br>我的互联网入门书，算是我看过的最容易懂的网络书了。推荐给大家入门  </p>
<h3 id="图解TCP-x2F-IP"><a href="#图解TCP-x2F-IP" class="headerlink" title="图解TCP&#x2F;IP"></a>图解TCP&#x2F;IP</h3><p><img src="/../someimage/%E5%9B%BE%E8%A7%A3.jpg"><br>薄书，比上一本难且枯燥一些，推荐有一些基础再看，目前看了20%左右吧  </p>
<h3 id="挑战程序设计竞赛"><a href="#挑战程序设计竞赛" class="headerlink" title="挑战程序设计竞赛"></a>挑战程序设计竞赛</h3><p><img src="/../someimage/%E6%8C%91%E6%88%98.jpg"><br>人称白书，和紫书一起看的，大家说这本比紫书简单但是我不觉得。有些难点的算法和数据结构，比如状压dp，st表这种。跳着看的  </p>
<h3 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h3><p><img src="/../someimage/%E6%B7%B1%E5%85%A5.jpg"><br>计算机界有名的大厚书，并且是大二要上的一门课，对各种现象解释的非常底层和详尽。由于有对大书的畏惧，目前看了10%吧   </p>
<h3 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h3><p><img src="/../someimage/%E9%9D%A2%E5%90%91.jpg"><br>我大一上特爱这本书，带我入门了面向对象编程，写的巨好，把我看同类型的书觉得很难的东西春风化雨，写的特别好理解。是我看过的教c++面向对象里最好的书了，看了1.5遍…（ps但是依旧没有拯救我的java……  </p>
<h2 id="关于人生-x2F-生活"><a href="#关于人生-x2F-生活" class="headerlink" title="关于人生&#x2F;生活"></a>关于人生&#x2F;生活</h2><h3 id="影响力"><a href="#影响力" class="headerlink" title="影响力"></a>影响力</h3><p><img src="/../someimage/%E5%BD%B1%E5%93%8D.jpg"><br>会学到一些小技巧，比如目的是7就开口要10这种</p>
<h3 id="亲密关系"><a href="#亲密关系" class="headerlink" title="亲密关系"></a>亲密关系</h3><p>有很多有意思的调查  </p>
<h3 id="你不可不知的人性"><a href="#你不可不知的人性" class="headerlink" title="你不可不知的人性"></a>你不可不知的人性</h3><p><img src="/../someimage/%E4%BD%A0%E4%B8%8D.jpg"><br>刘庸的处事系列我都很喜欢，尤其是那本《我不是教你诈》，讲了好多令我叹为观止的人间套路……感觉看完这个系列后情商提高了  </p>
]]></content>
  </entry>
  <entry>
    <title>关于clion配置</title>
    <url>/2023/04/14/clion/</url>
    <content><![CDATA[<p>起岸希一开始配置好了各种编译环境。但是出现<strong>运行小三角灰色，无法运行</strong> 的情况。<br>如图所示：<img src="/../someimage/1.png"><br>解决方法：<br>1.检查是否配置好编译环境   </p>
<span id="more"></span>  


<p><img src="/../someimage/2.png"><br>注意！buildtool那三排下面如果有个黄三角警告是不行的。可能需要手动选择。按图上的来就好啦~</p>
<p>2.环境配好了注意储存项目的路径必须是全英文。如果是全英文但是问题依旧没有解决你应该是把项目存c盘了。c盘路径“用户”显示的是“users”，我猜是因为这个。可以在D盘中新开一个文件夹，重新存项目，新开好的项目如果生成这样一个cmake文件就没有问题啦~<img src="/../someimage/3.png"></p>
]]></content>
  </entry>
  <entry>
    <title>基于c和easyx的游戏开发</title>
    <url>/2023/03/22/easyx/</url>
    <content><![CDATA[<h2 id="一开始我本来想开发一个像橙光一样的翻页阅读样式的小游戏，带剧情那种……结果，发现easyx的性能对这种游戏模式支持的并不好"><a href="#一开始我本来想开发一个像橙光一样的翻页阅读样式的小游戏，带剧情那种……结果，发现easyx的性能对这种游戏模式支持的并不好" class="headerlink" title="一开始我本来想开发一个像橙光一样的翻页阅读样式的小游戏，带剧情那种……结果，发现easyx的性能对这种游戏模式支持的并不好"></a>一开始我本来想开发一个像橙光一样的翻页阅读样式的小游戏，带剧情那种……结果，发现easyx的性能对这种游戏模式支持的并不好</h2><p>所以我最后向前人低头（不是），还是改作马里奥那种技巧交互式游戏吧……<br>但是！！！马里奥没有教程啊！b站上搜不到一个完整的教程……也没有一个完整的代码包可以自己拿来运行看看实现……不是缺这个头文件就是缺那个素材，导致我只能自造轮子（悲）<br>我的地图是用tiled做的，需要解析json文件，但是相关讲解视频b站上只找到一个，而且代码在我的机器上还跑不了（别问，问就是访问权限冲突），至于到底是怎么从jSON文件的一堆数字变成一块块的能运行出来的地图我也不知道啊！！<br>制作过程中遇到了很多问题，以下列了一个清单：  </p>
<span id="more"></span>

<ol>
<li>easyx的字符集问题  </li>
<li>如何实现链表文件存储  </li>
<li>如何实现链表排序（排行榜）  </li>
<li>单击实现翻页  </li>
<li>让messagebox显示在图形界面上层</li>
</ol>
<hr>
<p>好崩溃（划掉） </p>
<h2 id="1-有关字符集"><a href="#1-有关字符集" class="headerlink" title="1.有关字符集"></a>1.有关字符集</h2><p>据我了解，程序默认unicode字符集。“使用多字节字符集”和“使用Unicode字符集”的直接区别就是：编译器是否增加了宏定义——UNICODE。当选择“使用Unicode字符集”时，编译器会增加宏定义——UNICODE。而是否增加了宏定义UNICODE，则影响了一些Windows API的使用。例如：<br><code>MessageBox(NULL, L&quot;这是一个测试程序!&quot;, L&quot;Title&quot;, MB_OK);</code>这些api接受tchar类型的字符串，如果有unicode定义tchar就相当于LPCWSTR，否则tchar等同于char。所以如果使用Unicode，为了让api读懂char，我们使用_T””，或者L””转义。  </p>
<h2 id="2-链表文件读写"><a href="#2-链表文件读写" class="headerlink" title="2.链表文件读写"></a>2.链表文件读写</h2><p>主要是链表里的东西怎么进入文件，函数如下：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">saveStuInfo</span><span class="params">(link*lin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!lin-&gt;length)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;链表里没得东西\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;stu.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;打不开文件\n&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       node* a = lin-&gt;head;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%s %s %d\n&quot;</span>, a-&gt;name, a-&gt;passw, a-&gt;grade);</span><br><span class="line">           a = a-&gt;next;</span><br><span class="line">       &#125; <span class="keyword">while</span> (a != <span class="literal">NULL</span>); </span><br><span class="line">       <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-链表排序"><a href="#3-链表排序" class="headerlink" title="3.链表排序"></a>3.链表排序</h2><p>偷懒了，用的map，老师轻点扣分，毕竟这也说明我十分勤奋的学习了c++不是吗（）</p>
<h2 id="4-单击翻页"><a href="#4-单击翻页" class="headerlink" title="4.单击翻页"></a>4.单击翻页</h2><p>将图片一张张存到结构体，每次识别到鼠标左键按下打印下一张，可以使用batchdraw清屏打印</p>
<h2 id="5-messagebox显示"><a href="#5-messagebox显示" class="headerlink" title="5.messagebox显示"></a>5.messagebox显示</h2><p>一开始我发现我的提示box老被游戏界面挡住，也就是说显示在游戏下层，后来多方搜索我发现是这个参数<br><code>MessageBox(hnd, &quot;\t登录成功&quot;, &quot;提示&quot;, MB_OKCANCEL);</code>注意那个<strong>hnd</strong>！！<code>HWND hnd = GetHWnd();</code>一定要写窗口句柄，一开始我那里写的null，就被盖住了。。。。</p>
<hr>
<h1 id="以上都是简单问题，下面是真正难题"><a href="#以上都是简单问题，下面是真正难题" class="headerlink" title="以上都是简单问题，下面是真正难题"></a>以上都是简单问题，下面是真正难题</h1><ol start="7">
<li>马里奥如何判定碰到东西  </li>
<li>jSON文件如何实现到自己的程序上变成地图</li>
<li>如何让马里奥动起来</li>
<li>镜头跟随</li>
<li>除了主角外地图上其他东西怎么动起来（如金币）</li>
<li>最大的问题是<strong>怎么平衡写代码的时间和学课内知识的时间啊啊啊啊啊！</strong></li>
</ol>
<h2 id="1-马里奥碰撞判定"><a href="#1-马里奥碰撞判定" class="headerlink" title="1.马里奥碰撞判定"></a>1.马里奥碰撞判定</h2><p>一开始本来想着解析json文件，后来实在不会于是开了个巨大的二维数组记录地图信息，哪个格子有东西哪个没有，数字内容代表东西是什么。。。像这样<img src="/../someimage/wew.png"><br>然后就检测人的上下左右有没有撞到有东西的格子，这个判定我当时想了两天，晚上睡觉闭上眼睛也在想。。。</p>
<h2 id="2-json-gt-地图"><a href="#2-json-gt-地图" class="headerlink" title="2.json-&gt;地图"></a>2.json-&gt;地图</h2><p>说实话偷懒了，直接将做出来的地图导出成png了哈哈哈哈哈</p>
<h2 id="3-马里奥如何动起来"><a href="#3-马里奥如何动起来" class="headerlink" title="3.马里奥如何动起来"></a>3.马里奥如何动起来</h2><p>目前的办法是循环贴图贴背景，belike：  </p>
<pre><code>    while (1) &#123;
        putimage(mpx, 0, res.img_homeSubPage);//贴背景
        drawImg(x, y,108*n,0, 108,0,&amp;img);//贴人物，每次贴一个动态
        n++;
        if (n &gt;= 24)n = 0;//一共24个动态
        Sleep(20);
    &#125;
</code></pre>
<p>drawimg函数可以直接贴png格式图片，不用掩码图！！！！这个函数是同学网上找的，被我改了改，七个参数方便贴动态图。强烈推荐这个函数，贴出来的图比掩码图清晰，掩码图p不好的话贴出来有黑边（悲）    </p>
<pre><code>typedef struct _ARGB &#123;
byte a;
byte r;
byte g;
byte b;
&#125;ARGB;
ARGB color2Argb(DWORD c) &#123;
ARGB res;
res.r = (byte)c;
res.g = (byte)(c &gt;&gt; 8);
res.b = (byte)(c &gt;&gt; 16);
res.a = (byte)(c &gt;&gt; 24);
return res;
&#125;
DWORD argb2Color(ARGB c) &#123;
DWORD t = RGB(c.r, c.g, c.b);
return ((DWORD)c.a) &lt;&lt; 24 | t;
&#125;
void toGray(IMAGE* src) &#123;
DWORD* psrc = GetImageBuffer(src);
for (int i = 0; i &lt; src-&gt;getwidth() * src-&gt;getheight(); i++) &#123;
    ARGB t = color2Argb(psrc[i]);
    byte arv = (t.r + t.g + t.b) / 3;
    ARGB res = &#123; t.a,arv,arv,arv &#125;;
    psrc[i] = argb2Color(res);
&#125;
&#125;
</code></pre>
<p>前面都是结构体，下面是输出函数，到时候直接调用函数就好  </p>
<pre><code>void drawImg(int x, int y,int u,int m,int k,int d, IMAGE* src) &#123;
//从背景坐标x,y开始打印，打印图上u，m开始，宽k高d的部分
DWORD* pwin = GetImageBuffer();
DWORD* psrc = GetImageBuffer(src);
int win_w = getwidth();
int win_h = getheight();
int src_w = src-&gt;getwidth();

//int src_h = src-&gt;getheight();
int real_w = (k-u&gt; win_w) ? win_w - x : k;
int real_h = (d-m &gt; win_h) ? win_h - y : d;
if (x &lt; 0) &#123;
    psrc += -x; real_w -= -x; x = 0;
&#125;
if (y &lt; 0) &#123;
    psrc += (d * -y); real_h -= -y; y = 0;
&#125;
pwin += (win_w * y + x);
psrc += (src_w * m + u);
for (int iy = 0; iy &lt; real_h; iy++) &#123;
    for (int ix = 0; ix &lt; real_w; ix++) &#123;
        byte a = (byte)(psrc[ix] &gt;&gt; 24);
        if (a &gt; 100) &#123;
            pwin[ix] = psrc[ix];
        &#125;
    &#125;
    pwin += win_w;
    psrc += src_w;
&#125;
&#125;
</code></pre>
<p>实现效果：<img src="/../someimage/321.png"></p>
<h2 id="4-镜头跟随"><a href="#4-镜头跟随" class="headerlink" title="4.镜头跟随"></a>4.镜头跟随</h2><p>判定人物坐标，比如画面中央时500，500前不向后撤地图，500后人物不往前走，改为向后撤地图，map.x-&#x3D;step;</p>
<h2 id="5-金币动态"><a href="#5-金币动态" class="headerlink" title="5.金币动态"></a>5.金币动态</h2><p>方法时逐帧绘制，就是人动和金币动在一个计时循环里，金币四张图存成数组，用i控制播放哪张</p>
<h2 id="6-无解"><a href="#6-无解" class="headerlink" title="6.无解"></a>6.无解</h2>]]></content>
  </entry>
  <entry>
    <title>工大杯比赛记录</title>
    <url>/2023/05/24/gdb/</url>
    <content><![CDATA[<h2 id="可能是因为大佬都没来，混了个好排名。。。"><a href="#可能是因为大佬都没来，混了个好排名。。。" class="headerlink" title="可能是因为大佬都没来，混了个好排名。。。"></a>可能是因为大佬都没来，混了个好排名。。。</h2><p><img src="/../someimage/5.jpg">  </p>
<span id="more"></span>  
<h2 id="比赛过程"><a href="#比赛过程" class="headerlink" title="比赛过程"></a>比赛过程</h2><p>需要感谢我自己的一点是比赛之前买了一杯一直想喝的奶茶，绿茶味的，很解困，加上是凉的，全程没怎么困过。。。这个比赛acm赛制让带资料，于是我带着我两本大书就去了，去了发现我不是阵仗最大的，一堆人拿着什么c primer什么c语言程序设计就来了，还有带物理作业的，我顿时就不紧张了。。。见到了久仰的大佬ysm，还是他来跟我打的招呼。。。比赛的时候真的很离谱，1:30了大家都开始写了我校园网还没上去2333，边上的大哥告诉我校园网网址才上去的。写了5题，一共8题，爽。  </p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>用时5min？<br>第一道题就让我很困惑。。。找数据就行，答案非常明显一眼就能看出，但是出题人小熊还是水了一页的字…找到答案后我都不敢置信。。一页的数据，那么多字，答案就这？但是看榜上大家都ac了一遍过，我心想也不能有什么坑，然后就交了,ac。至今我也不清楚他为什么给了那么多数据。  </p>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>用时30min<br>b题是另一个学长出的，有很多小坑点，擦边过的特判，任何时刻鸟都不能沾地啥的，写了老长，五六十行吧。第一次交没过，心态崩了往后写了，一个小时后我还是只过了A一道题，b和e都wa。返回来看的时候发现了一条补充说明。。。改改过了。</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>用时1h<br>这题我写的时候距离比赛结束还有一个小时，我当时排名30多，已经封榜了（这个真的坑，我一开始不知道封榜还寻思为什么做出的题变蓝了）就想着无所谓了爱对不对吧，我上学期11月蓝桥也是30多名，不就是毫无进步么，无所谓（悲）而且c题是我很久没练的树题！！当时看榜上比我强的基本就是C和F写了，然后C过的最多，我想着他最简单就开始尝试。写着写着我发现他不是二叉树，这就说明这应该不是道建树的题，每个给出father，所以我想着fa数组保存就不建树了，这样还挺简单的，最后证明我的想法是对的。。。<br>C题考的是最大未污染子树，我当时一看题以为要建树，而且这名字很耳熟，应该之前在学堂在线看过，但是没研究过，不过我当时其他的应该也不会了，于是我打算自创算法（）<br>就用fa保存整个树，re保存每个点红不红，ans保存每个点开始的子树数量。然后遍历每个点，如果这个点红就把他所有父亲标红，不红就把他自己和所有父亲的ans+1，直到红父亲或者根。最后遍历ans找最大的节点就是答案。我16的时候交了一次wa了，然后发现没看清题，找不到的时候要输出-1，然后又自己创造样例输入发现有个循环没进，这时候24了，各种调试发现原来是应该&lt;&#x3D;n写成&lt;n了，改完这些已经28了，我赶紧交了，剩下的就听天由命了，然后我看他那个评测一直转一直转我就害怕，然后！！居然过了！！我那一刻都快哭了，二叉树没白学，题没白做啊啊啊啊。。然后就29了，我躺尸等待考试结束。。。。好久没经历这么刺激的考试结束前7分钟了，真就创造奇迹，感觉把我排名拉高了十几名。。真就一念之间<img src="/../someimage/he.jpg"></p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>用时30min<br>小熊出的题，我当时想着一定要过，考哈希表嘛，我寻思看着很简单啊，遂交，wa。然后我觉得我的判断条件逻辑不好，遂改，又交，wa。然后自己想了几组数据测试，还真测出问题来了，判断的||写成&amp;&amp;了，你说怎么可能有数在&lt;1800的同时&gt;29597呢。改了，遂ac</p>
<h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>用时40min<br>这题是第4个过的，真的写爽了，快说，感谢ysm。。。各种STL啪啪往上招呼好快乐，一开始用的map后来发现不行，他（应该）没有按键key排完按value排的特性（按数字排序，同数字按名字排序），遂换priority_queue。发现也不行，他也不是先按pair的first排完按second。但是我有书啊！！我直接翻书哈哈哈哈哈，写了个cmp结构体给整出来了，<code>if(p1.first!=p2.first)return p1.first&lt;p2.first;   else return p1.second&gt;p2.second;</code>。不知道为什么两个符号是反的，反正结果是对的（狗头）我头一次体验到带书上阵的魅力。幸好没出bug，否则还真不会改。。。因为不了解实现。有句话说得好：</p>
<blockquote>
<p>我们至今仍未知道那题ac的原因  </p>
</blockquote>
<p>笑死。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经历过蓝桥杯和天梯赛的暴打可能人变踏实了一点。专心刷了几道不会的题，心态上也不那么狂了，轻易不尝试自己以前拿ide都调半天的题（这次的c是个例外哈哈哈，临时发挥出来了），devcpp越发熟练了，调试上没出大问题，比如“一顿操作猛如虎，运行一看没输出”这种，这次没有写出没输出的程序，也没有dfs啥的难调试的东西，就是基本理论想明白了实际就没什么别的问题。调程序很好的方法就是自己多创造几个样例，咱可以模拟那种很小的输入比如只有一两个点，一般就能看出问题了。<br>我要吐槽！学校破电脑黑窗口不能ctrl+v……每个测试例都要手动输入！！h题那个输入就逆天，电脑类型MacBook_Pro_19_2023，崩溃每次都来一遍，我都记下来了。。。</p>
]]></content>
  </entry>
  <entry>
    <title>起岸希的第一篇博客</title>
    <url>/2023/03/21/first/</url>
    <content><![CDATA[<h2 id="好激动"><a href="#好激动" class="headerlink" title="好激动"></a>好激动</h2><p>对于一些计算机学习心得<br>起岸希觉得有必要分享一下  </p>
<span id="more"></span>
<p>首先记录一下<strong>markdown</strong>语法</p>
<blockquote>
<p>引用一下</p>
</blockquote>
<p>好了（空行退出引用段落）<br>插入代码段<br>空一行在打代码，每行前加一个tab</p>
<pre><code>int f[MAXN][21]; // 第二维的大小根据数据范围决定，不小于log(MAXN)
    for (int i = 1; i &lt;= n; ++i)
        f[i][0] = read(); // 读入数据
for (int i = 1; i &lt;= 20; ++i)
    for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j)
        f[j][i] = max(f[j][i - 1], f[j + (1 &lt;&lt; (i - 1))][i - 1]);
</code></pre>
<p>将单词变为代码<code>the fool</code>一个反引号包裹单词</p>
<hr>
<p>分割线<br>这是一个<a href="https://markdown.com.cn/basic-syntax/links.html">markdown语法链接</a><br>这是起岸希的email：<a href="mailto:&#x34;&#51;&#x30;&#x33;&#54;&#50;&#51;&#x38;&#x35;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#109;">&#x34;&#51;&#x30;&#x33;&#54;&#50;&#51;&#x38;&#x35;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#109;</a><br>这是图片 <img src="/../someimage/wdt.jpg" alt="picture">  </p>
]]></content>
  </entry>
  <entry>
    <title>蓝桥杯2022年题目思路</title>
    <url>/2023/03/29/lanqiao/</url>
    <content><![CDATA[<h2 id="E：爬树的甲壳虫"><a href="#E：爬树的甲壳虫" class="headerlink" title="E：爬树的甲壳虫"></a>E：爬树的甲壳虫</h2><p>状态转移方程：<img src="/../someimage/wsl.png">  </p>
<span id="more"></span>  

<p>其中i&#x3D;0,1…n。a[i]代表<strong>从a[i]开始爬到树顶的期望时间</strong>，即a[i-1]有p[i]的可能爬上a[i]并且继承a[i]的期望时间。有1-p[i]的可能掉到树根，从头来过，继承a[0]的时间。a[0]指从根开始爬到树顶的时间。</p>
]]></content>
  </entry>
  <entry>
    <title>关于ST表</title>
    <url>/2023/03/21/second/</url>
    <content><![CDATA[<h3 id="定义：用于求可重复性贡献问题的解。（即重复计算结果不变）对于一个一维数组，采用分治的方法，用一个二维数组储存每个区间内的最大最小值。f-a-b-表示从a开始2的b次方个数的最大值"><a href="#定义：用于求可重复性贡献问题的解。（即重复计算结果不变）对于一个一维数组，采用分治的方法，用一个二维数组储存每个区间内的最大最小值。f-a-b-表示从a开始2的b次方个数的最大值" class="headerlink" title="定义：用于求可重复性贡献问题的解。（即重复计算结果不变）对于一个一维数组，采用分治的方法，用一个二维数组储存每个区间内的最大最小值。f[a][b]表示从a开始2的b次方个数的最大值"></a>定义：用于求可重复性贡献问题的解。（即重复计算结果不变）对于一个一维数组，采用分治的方法，用一个二维数组储存每个区间内的最大最小值。<code>f[a][b]</code>表示从a开始2的b次方个数的最大值</h3><p>状态转移方程：f ( i , j ) &#x3D; m a x ( f ( i , j − 1 ) ,   f ( i + 2^(j − 1) , j − 1 ) )  </p>
<span id="more"></span>  

<p>将原区间分成两个大小相等子区间（因为长度是2的j次方，所以不存在不能等分的情况）<br>代码如下</p>
<pre><code>int f[MAXN][21]; // 第二维的大小根据数据范围决定，不小于log(MAXN)
    for (int i = 1; i &lt;= n; ++i)
           f[i][0] = read(); //读入数据
for (int j = 1; j &lt;= 20; ++j)//枚举倍数
    for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)//枚举起点,i到i+2^j-1刚好2^j个数
        f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j- 1))][j- 1]);
</code></pre>
<p>内部存储像这样 <img src="/../someimage/02.jpg" alt="picture"><br>对于询问(l,r)，寻找两个分别以l开头和以s结尾的区间，两区间的最大值即总最大值。我们需要使第一个子区间的右端点尽可能的接近r​，那么不妨直接令l + 2^s − 1 &#x3D; r即s&#x3D;lg[ r-l+1]向下取整。则区间[l,r]被分为：f[ l ][ l + 2^s - 1]和f[r-( 2^s -1)][ r ]  <strong>从l开始2^s个，从r往前2^s个</strong><br>对log进行预处理：<code>lg[i]=lg[i/2]+1;</code>,<code>lg[0]=-1;</code><strong>千万别忘！</strong>  </p>
]]></content>
  </entry>
  <entry>
    <title>pta天梯赛补题——蒟蒻不愿再拖后腿</title>
    <url>/2023/04/19/tianti/</url>
    <content><![CDATA[<h2 id="L1-017到底有多二"><a href="#L1-017到底有多二" class="headerlink" title="L1-017到底有多二"></a>L1-017到底有多二</h2><p>ac code:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a;</span><br><span class="line"><span class="type">int</span> k,q=<span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> n,e=<span class="number">1</span>,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]==<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> d=a.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!(a[a.<span class="built_in">size</span>()<span class="number">-1</span>]&amp;<span class="number">1</span>))q=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)&#123;e=<span class="number">1.5</span>;d--;&#125;</span><br><span class="line">    n=(<span class="type">double</span>)k/d;</span><br><span class="line">    ans=n*(<span class="type">double</span>)q*e*<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf%%&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>我一开始数字长度d是用<code>int d=(a[0]==&#39;-&#39;?(a.size()-1):(a.size()-2));</code>写的，但是测试点2，4过不去。。。改成特判就好了，想了一下，因为长度就是位数。。不需要再减。应该是不减和减一，后者误打误撞对了。所以测试点2，4应该是正数~~~其他的都是负数</p>
<h2 id="L1-095分寝室"><a href="#L1-095分寝室" class="headerlink" title="L1-095分寝室"></a>L1-095分寝室</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">   set&lt;<span class="type">int</span>&gt;v, v1;</span><br><span class="line">   <span class="type">int</span> a, b, c, ans1, ans2, k,d=INF;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">getc</span><span class="params">(set&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           v.<span class="built_in">insert</span>(i);</span><br><span class="line">           v.<span class="built_in">insert</span>(n / i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> it1 = v1.<span class="built_in">begin</span>(); it1 != v1.<span class="built_in">end</span>(); it1++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (*it + *it1 == a)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="type">int</span> temp = b / (*it), temp1 = c / (*it1);</span><br><span class="line">               <span class="keyword">if</span> (<span class="built_in">abs</span>(temp - temp1 )&lt; d) &#123;</span><br><span class="line">                   ans1 = *it; ans2 = *it1;</span><br><span class="line">                   d =<span class="built_in">abs</span>( temp - temp1);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin&gt;&gt;b&gt;&gt;c&gt;&gt;a;</span><br><span class="line">   <span class="built_in">getc</span>(v,b);</span><br><span class="line">   <span class="built_in">getc</span>(v1,c);</span><br><span class="line">   <span class="built_in">solve</span>();</span><br><span class="line">   <span class="keyword">if</span> (d != INF)</span><br><span class="line">       cout &lt;&lt; ans1&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; ans2;</span><br><span class="line">   <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这破题我在考场上只得了2分，一共20分，没错，就是输出no solution这两分……我很崩溃说实话，但是我把方法想复杂了，人家大佬十几行解决问题，而我40多行今天由调了半个多小时才ac。<br>之前错在  </p>
<ol>
<li>自己不是很清楚每步求的啥……我set里放的是可能的寝室数而不是一个寝室可能的人数……  </li>
<li>c打成b了,关键是样例还过了，我自己测了几个样例也没问题，就离谱</li>
</ol>
<p>说一下和大佬思路的差距，我想着求出所有因子，for循环嵌套找加起来等于n的再细算。大佬从1枚举到n，只要一层循环枚举两边寝室数然后判断能不能被总人数整除。从时间复杂度和行数上讲，我的思路都弱爆了  </p>
<h2 id="L2-045堆宝塔"><a href="#L2-045堆宝塔" class="headerlink" title="L2-045堆宝塔"></a>L2-045堆宝塔</h2><p>ac code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, s[<span class="number">2000</span>], cou = <span class="number">0</span>, maxx;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;a, b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clear</span><span class="params">(stack&lt;<span class="type">int</span>&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swi</span><span class="params">(stack&lt;<span class="type">int</span>&gt;&amp; s, <span class="type">int</span> aa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &gt; aa)</span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">push</span>(s[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">empty</span>() || s[i] &lt; a.<span class="built_in">top</span>())</span><br><span class="line">            a.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b.<span class="built_in">empty</span>() || s[i] &gt; b.<span class="built_in">top</span>())</span><br><span class="line">            b.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//int r = a.top();</span></span><br><span class="line">            <span class="type">int</span> ck = <span class="built_in">clear</span>(a);</span><br><span class="line">            <span class="built_in">swi</span>(b, s[i]);</span><br><span class="line">            a.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            maxx = <span class="built_in">max</span>(maxx, ck);</span><br><span class="line">            cou++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!a.<span class="built_in">empty</span>()) &#123; cou++; maxx = <span class="built_in">max</span>(maxx, (<span class="type">int</span>)a.<span class="built_in">size</span>()); &#125;<span class="comment">//很重要</span></span><br><span class="line">    <span class="keyword">if</span> (!b.<span class="built_in">empty</span>()) &#123; cou++; maxx = <span class="built_in">max</span>(maxx, (<span class="type">int</span>)a.<span class="built_in">size</span>()); &#125;</span><br><span class="line">    cout &lt;&lt; cou &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个我还真没看见啥简单方法，入栈出栈很难调，赛场上崩溃了也只拿了15分，一共25分。就是看清题意，用top前先判空。</p>
<h2 id="L2-046天梯赛的赛场安排"><a href="#L2-046天梯赛的赛场安排" class="headerlink" title="L2-046天梯赛的赛场安排"></a>L2-046天梯赛的赛场安排</h2><p>24分code:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, c, temp, v;</span><br><span class="line">string u;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vv;</span><br><span class="line">vector&lt;string&gt;ss;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, string&gt;&gt;q;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vv.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vv[i] + a &lt;= c)</span><br><span class="line">        &#123;</span><br><span class="line">            vv[i] += a;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    temp = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123; v,u &#125;);</span><br><span class="line">        ss.<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        v = q.<span class="built_in">top</span>().first;</span><br><span class="line">        u = q.<span class="built_in">top</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (v &gt;= c) &#123; </span><br><span class="line">            vv.<span class="built_in">push_back</span>(c);</span><br><span class="line">            v -= c;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123; v,u &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">find</span>(v))</span><br><span class="line">                vv.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        mp[u] += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ss[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mp[ss[i]] &lt;&lt; endl;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; vv.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主打一个ac但没有完全ac，有一个点T了，别问，问就是没想到简单方法，大佬说直接那人数除c取余再入队就好了，我搁这搁这呢。想一想确实啊，大于c的时候队列顺序不影响赛场数，直到最大的小于c的数入队，然后第二大……就当熟悉stl了，今天学到的冷知识：unordered_map居然是随机的，完全无序。pair取出后用.访问元素，优先队列先按first排序再按second  </p>
<h2 id="L2-048寻宝图"><a href="#L2-048寻宝图" class="headerlink" title="L2-048寻宝图"></a>L2-048寻宝图</h2><p>这题在考场上写了一个小时，2分好像，妈的破防了。devcpp那个傻逼调试我调了半天才发现我把字符串当int存了，但是只会硬拆。。。直到自己补题的时候还在用数组mp[][]存图，上网查之后才知道string[]存图和二维数组性能一样。。。。<br>ac code:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, ch[<span class="number">5</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;, ch1[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> num, ans, f;</span><br><span class="line">string mp[<span class="number">100005</span>];<span class="comment">//如果int[][]会数组过大，以后记得1e5以上的就别开二维了。。。</span></span><br><span class="line">string a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mp[a][b] &gt; <span class="string">&#x27;1&#x27;</span> &amp;&amp; mp[a][b] &lt;= <span class="string">&#x27;9&#x27;</span>)f = <span class="number">1</span>;</span><br><span class="line">    mp[a][b] = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//开不了vis数组干脆踩到置0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = a + ch[i], s = b + ch1[i];</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=<span class="number">0</span>&amp;&amp;k&lt;n&amp;&amp;s&gt;=<span class="number">0</span>&amp;&amp;s&lt;m&amp;&amp;mp[k][s]&gt;<span class="string">&#x27;0&#x27;</span>)<span class="comment">//最偏离我思考的，不需要的别踩。。。</span></span><br><span class="line">            <span class="built_in">dfs</span>(k, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; mp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[i][j]!=<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j);</span><br><span class="line">                <span class="keyword">if</span> (f)num++;</span><br><span class="line">                ans++;</span><br><span class="line">                f = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我现在都不知道为什么这一版过了而二维数组版没过。。按理来说样例很小两种方法应该没区别。可能是因为我自己写的那版的思路是：</p>
<ol>
<li>边界：踩到0返回</li>
<li>四种偏移只要不超界都踩一遍</li>
<li>用vis数组保存踩过的非0，main函数判断没踩过的非零开始dfs。后来让vis保存踩过的所有也不行，不会了。。。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2023/04/03/xianduanshu/</url>
    <content><![CDATA[<h2 id="节点：线段树节点每个代表一个区间，用二分法将每个区间依次减半直到最小，故节点数量是元素数量的二倍。节点内包含三个部分："><a href="#节点：线段树节点每个代表一个区间，用二分法将每个区间依次减半直到最小，故节点数量是元素数量的二倍。节点内包含三个部分：" class="headerlink" title="节点：线段树节点每个代表一个区间，用二分法将每个区间依次减半直到最小，故节点数量是元素数量的二倍。节点内包含三个部分："></a>节点：线段树节点每个代表一个区间，用二分法将每个区间依次减半直到最小，故节点数量是元素数量的二倍。节点内包含三个部分：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, mx;<span class="comment">//mx为每个区间内要维护的数值（通常为最大，最小值）</span></span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<span id="more"></span>  

<h2 id="建树："><a href="#建树：" class="headerlink" title="建树："></a>建树：</h2><pre><code>void build(int u, int l, int r) &#123;//初始化 u:节点编号 从根节点（编号最小的）向下递归
if (l == r)tr[u] = &#123; l,r,0 &#125;;
else &#123;
    tr[u] = &#123; l,r,0 &#125;;
    int mid = l + r &gt;&gt; 1;
    build(u*2, l, mid), build(u*2+1, mid + 1, r);
    &#125;
&#125;
</code></pre>
<h2 id="维护："><a href="#维护：" class="headerlink" title="维护："></a>维护：</h2><pre><code>inline void pushup(int u) &#123;
tr[u].mx = max(tr[ul].mx, tr[ur].mx);//维护max
&#125;
</code></pre>
<h2 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h2><pre><code>void modify(int u, int d, int f) &#123;//当前节点编号 要修改的节点编号 改成什么
if (tr[u].l == d &amp;&amp; tr[u].r == d) &#123;
    tr[u].mx = f;
&#125;
else &#123;
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    if (mid &gt;= d)modify(u*2, d, f);
    if (mid &lt; d)modify(u*2+1, d, f);
    pushup(u);
&#125;
&#125;
</code></pre>
<h2 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h2><pre><code>int query(int u, int l, int r) &#123;
if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;
    return tr[u].mx;
&#125;
else &#123;
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    int t = 0;
    if (mid &gt;= l)t = query(u*2, l, r);
    if (mid &lt; r)t = max(t, query(u*2+1, l, r));
    return t;
&#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>洛谷题解</title>
    <url>/2023/04/25/%E6%B4%9B%E8%B0%B7/</url>
    <content><![CDATA[<h2 id="P2089-烤鸡"><a href="#P2089-烤鸡" class="headerlink" title="P2089 烤鸡"></a>P2089 烤鸡</h2><p>考点：深搜 剪枝 回溯（记录路径） </p>
<span id="more"></span>  


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> 	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,ans,a[<span class="number">12</span>],aa[<span class="number">10007</span>][<span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	aa[n][i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sum, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sum == n &amp;&amp; pos == <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">	ans++;</span><br><span class="line">	<span class="built_in">save</span>(ans);<span class="comment">//正确：存答案</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sum &gt;= n) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="number">10</span>) <span class="keyword">return</span>;</span><br><span class="line">a[pos] = <span class="number">1</span>;<span class="comment">//记录路径数组</span></span><br><span class="line"><span class="built_in">dfs</span>(sum + <span class="number">1</span>, pos+<span class="number">1</span>);</span><br><span class="line">a[pos] = <span class="number">2</span>;<span class="comment">//回溯</span></span><br><span class="line"><span class="built_in">dfs</span>(sum + <span class="number">2</span>, pos+<span class="number">1</span>);</span><br><span class="line">a[pos] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">dfs</span>(sum + <span class="number">3</span>, pos+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=ans; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		cout &lt;&lt; aa[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P1618-三连击"><a href="#P1618-三连击" class="headerlink" title="P1618 三连击"></a>P1618 三连击</h2><p>深搜&#x2F;枚举每个成比例的三位数判重</p>
<pre><code class="cpp">#include&lt;iostream&gt;
using namespace std;
int k,b,c,f;
int used[11],a[10];
int tonum(int n)
&#123;
    int sum=0;
    for(int i=3*n-2;i&lt;=3*n;i++)
    &#123;
        sum*=10;
        sum+=a[i];
    &#125;
    return sum;
&#125;
void dfs(int n)
&#123;
    if(n==10&amp;&amp;tonum(1)*b==tonum(2)*k&amp;&amp;tonum(2)*c==tonum(3)*b)
    &#123;cout&lt;&lt;tonum(1)&lt;&lt;&quot; &quot;&lt;&lt;tonum(2)&lt;&lt;&quot; &quot;&lt;&lt;tonum(3)&lt;&lt;endl;
        f=1;
    &#125;
    for(int i=1;i&lt;10;i++)
        if(!used[i])
            &#123;
                used[i]=1;
                a[n]=i;
                dfs(n+1);
                used[i]=0;
            &#125;
&#125;
int main()
&#123;
    cin&gt;&gt;k&gt;&gt;b&gt;&gt;c;
    dfs(1);
    if(!f)cout&lt;&lt;&quot;No!!!&quot;;
&#125;
</code></pre>
<h2 id="UVA816-bfs迷宫"><a href="#UVA816-bfs迷宫" class="headerlink" title="UVA816  bfs迷宫"></a>UVA816  bfs迷宫</h2><p>code:  </p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
string name;
int stap1, stap2, goal1, goal2;
char fx;
int has_e[10][10][10][10];
int d[10][10][5];
struct Node &#123;
    int x, y, dir;
    Node(int x, int y, int dir) :x(x), y(y), dir(dir) &#123;&#125;
    Node() &#123;&#125;
&#125;;
Node p[10][10][5];
int dr[] = &#123; -1,0,1,0 &#125;;//对应NESW
int dc[] = &#123; 0,1,0,-1 &#125;;
const char* dirs = &quot;NESW&quot;;
const char* turns = &quot;FLR&quot;;
int dir_id(char ch) &#123; return strchr(dirs, ch) - dirs; &#125;
int turn_id(char c) &#123; return strchr(turns, c) - turns; &#125;
bool read()
&#123;
    cin &gt;&gt; name;
    if (name == &quot;END&quot;)return false;
    cin &gt;&gt; stap1 &gt;&gt; stap2 &gt;&gt; fx &gt;&gt; goal1 &gt;&gt; goal2;
    int x=0, y=0;
    while (cin &gt;&gt; x &amp;&amp; x)
    &#123;
        cin &gt;&gt; y;
        string s;
        while (cin &gt;&gt; s &amp;&amp; s != &quot;*&quot;)
        &#123;
            for(int i=1;i&lt;s.size();i++)
            has_e[x][y][dir_id(s[0])][turn_id(s[i])]=1;
        &#125;
    &#125;
    has_e[stap1][stap2][dir_id(fx)][0] = 1;
    return true;
&#125;

Node walk(const Node&amp; u, int turn)
&#123;
    int dir = u.dir;
    if (turn == 1)
    &#123;
        dir = (dir + 3) % 4;
    &#125;
    if (turn == 2)dir = (dir + 1) % 4;
    return Node(u.x+dr[dir], u.y+dc[dir], dir);//往某个方向走的下一格和朝向
&#125;
void print_ans(Node&amp; u)
&#123;
    vector&lt;Node&gt;nodes;
    for (;;) &#123;
        nodes.push_back(u);
        if (d[u.x][u.y][u.dir] == 0)
            break;
        u = p[u.x][u.y][u.dir];
    &#125;
    //nodes.push_back(Node(stap1, stap2, dir_id(fx)));
    int cnt = 0;
    for (int i = nodes.size() - 1; i &gt;= 0; i--)
    &#123;
        if (cnt % 10 == 0)cout &lt;&lt; &quot; &quot;;
        printf(&quot; (%d,%d)&quot;, nodes[i].x, nodes[i].y);
        if (++cnt % 10 == 0)cout &lt;&lt; endl;

    &#125;
    if (nodes.size() % 10 != 0)cout &lt;&lt; endl;
&#125;
void bfs()
&#123;
    queue&lt;Node&gt;q;
    memset(d, -1, sizeof(d));
    Node u(stap1, stap2, dir_id(fx));
    d[u.x][u.y][u.dir] = 0;
    q.push(u);
    while (!q.empty())
    &#123;
        Node u = q.front(); q.pop();
        if (u.x == goal1 &amp;&amp; u.y == goal2) &#123; print_ans(u); return; &#125;
        for (int i = 0; i &lt; 3; i++)
        &#123;
            //三个方向都试试看能不能走
            Node v = walk(u, i);
            if (has_e[u.x][u.y][u.dir][i] &amp;&amp; v.x &gt;= 0 &amp;&amp; v.x &lt;= 9 &amp;&amp; v.y &gt;= 0 &amp;&amp; v.y &lt;= 9 &amp;&amp; d[v.x][v.y][v.dir] &lt; 0)
            &#123;
                d[v.x][v.y][v.dir] = d[u.x][u.y][u.dir] + 1;
                p[v.x][v.y][v.dir] = u;
                q.push(v);
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; &quot;  No Solution Possible&quot; &lt;&lt; endl;
&#125;
int main()
&#123;
    while (read())
    &#123;
        cout &lt;&lt; name &lt;&lt; endl;
        bfs();
    &#125;
&#125;
</code></pre>
<p>蒟蒻照着竞赛书写的首个100行以上代码，本程序的最妙之处是位移函数和方向绑定。两套表示方向的体系NEWS是总方向，FLR是具体到每个节点能走的方向。根据人到达这个节点的朝向结合FLR枚举可以去的朝向（NEWS），此时注意朝向编号与位移编号对应。再根据图来筛选。基于此做BFS</p>
]]></content>
  </entry>
</search>
