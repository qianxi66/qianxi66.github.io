<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>蒟蒻的蓝桥杯省赛之旅</title>
    <url>/2023/04/11/2023/</url>
    <content><![CDATA[<h2 id="A-幸运数"><a href="#A-幸运数" class="headerlink" title="A:幸运数"></a>A:幸运数</h2><p>题目大意：寻找<code>100000000</code>内的长度为偶数的，前面一半和等于后面一半的数<br>code：  </p>
<span id="more"></span>  


<pre><code class="cpp">
#include&lt;iostream&gt;
#include&lt;string&gt;//我忘了tostring在这个头文件里了！
using namespace std;
int num;
int main() &#123;
    int n = 100000000;
    for (int i = 1; i &lt; n; i++)
    &#123;
        string a = to_string(i);
        if (a.size() &amp; 1)continue;
        else &#123;
            int s = a.size() / 2;
            int s1=0, s2 = 0;
            for (int i = 0; i &lt; s; i++)
            &#123;
                s1 += a[i] - &#39;0&#39;;
            &#125;
            for (int i = s; i &lt; a.size(); i++)
            &#123;
                s2 += a[i] - &#39;0&#39;;
            &#125;
            if (s1 == s2) &#123;
                cout &lt;&lt; a &lt;&lt; endl;
                num++;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; &quot;答案是&quot;&lt;&lt;num;
&#125;
</code></pre>
<p>答案4430091。可是！！！！！这个破玩意活生生运行了6分钟！！！！我考场上还以为是devcpp的问题，结果回来拿vs一弄发现。。。怎么也这么慢。不过细细一想就知道了。。。因为这是个O(n2)的算法。。。  </p>
<h2 id="B：有奖问答"><a href="#B：有奖问答" class="headerlink" title="B：有奖问答"></a>B：有奖问答</h2><p>题目大意：一共30道题，答对一题加10分，答错分数清零。你攒够100分就可以拿到奖品退出游戏。现在做完所有题后，你一共拿了70分。请问对于你答对的题有几种可能性<br>思路：暴搜。。。到达100剪枝<br>我知道我哪错了……我dfs的时候答错没给分数清零……这波是审题问题啊啊啊啊我哭死  </p>
<h2 id="C：平方差"><a href="#C：平方差" class="headerlink" title="C：平方差"></a>C：平方差</h2><p>题目大意：输入区间l，r。请你查找区间中有哪些数可以写成x^2-y^2的形式<br>思路：暴力打表……不会…打了1000以内的表，应该能水30%的点？</p>
]]></content>
  </entry>
  <entry>
    <title>蓝桥杯2020年题目思路</title>
    <url>/2023/04/06/2020/</url>
    <content><![CDATA[<h2 id="D七段码"><a href="#D七段码" class="headerlink" title="D七段码"></a>D七段码</h2><p>题目：<br><img src="/../someimage/asa.png"><br>注意两个三根棍相连地方对三根棍来说都算连接。难点：  </p>
<ol>
<li>将每个边抽象成一个点建图</li>
<li>枚举每个点亮不亮两种选择，共有2^7-1&#x3D;127种。将状态压缩为一个整数，每个灯亮不亮由0或1表示</li>
<li>判断每种组合是否联通：随便找一点dfs，用vis数组记录走过。最后遍历vis，若有为0的点则不连通</li>
</ol>
<span id="more"></span>  

<p>代码如下：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num,sum, q, cous, map[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">10</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuchu</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a%<span class="number">2</span>;</span><br><span class="line">		a/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[a] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">7</span>; j++)</span><br><span class="line">	&#123;<span class="comment">//儿子并且选出来并且没走过</span></span><br><span class="line">		<span class="keyword">if</span> (map[a][j] &amp;&amp; <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), j) != v.<span class="built_in">end</span>()&amp;&amp;!vis[j])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span> ,<span class="built_in">sizeof</span>(vis) );</span><br><span class="line">	q = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(v[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[v[i]] == <span class="number">0</span>)</span><br><span class="line">		q = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (q)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map[<span class="number">1</span>][<span class="number">2</span>] = map[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">1</span>][<span class="number">6</span>] = map[<span class="number">6</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">2</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">2</span>][<span class="number">3</span>]=map[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">4</span>] = map[<span class="number">4</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">4</span>][<span class="number">5</span>] = map[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">5</span>][<span class="number">6</span>]=map[<span class="number">6</span>][<span class="number">5</span>]=<span class="number">1</span>;</span><br><span class="line">map[<span class="number">5</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">6</span>][<span class="number">7</span>] = map[<span class="number">7</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) - <span class="number">1</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">7</span>; m++)</span><br><span class="line">		<span class="keyword">if</span> (i &gt;&gt; m &amp; <span class="number">1</span>)</span><br><span class="line">			v.<span class="built_in">push_back</span>(m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">check</span>(i))</span><br><span class="line">	&#123;</span><br><span class="line">		sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	v.<span class="built_in">clear</span>();<span class="comment">//清空v</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;答案：&quot;</span> &lt;&lt; sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../someimage/wa.png"></p>
]]></content>
  </entry>
  <entry>
    <title>天梯赛力挽狂澜局</title>
    <url>/2024/04/16/2024%E5%A4%A9%E6%A2%AF%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="L2-011-玩转二叉树"><a href="#L2-011-玩转二叉树" class="headerlink" title="L2-011 玩转二叉树"></a>L2-011 玩转二叉树</h2><p>学会建树吧。之前图简单搞string dfs，一点不会变通。想灵活还是得建树。。。栓Q<br>ac code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">int</span> rt, n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> lc, rc;</span><br><span class="line">&#125;node[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> mid[<span class="number">50</span>], pre[<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuchu</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node[s].lc)</span><br><span class="line">            q.<span class="built_in">push</span>(node[s].lc);</span><br><span class="line">        <span class="keyword">if</span> (node[s].rc)</span><br><span class="line">            q.<span class="built_in">push</span>(node[s].rc);</span><br><span class="line">        <span class="keyword">if</span> (s == pre[<span class="number">0</span>])</span><br><span class="line">            cout &lt;&lt; s;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)</span><span class="comment">//mid pre</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l1 &gt; r1)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l1; i &lt;= r1; i++)</span><br><span class="line">        <span class="keyword">if</span> (mid[i] == pre[l2]) &#123;</span><br><span class="line">            x = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> numleft = x - l1;</span><br><span class="line">    node[pre[l2]].rc = <span class="built_in">build</span>(l1, x - <span class="number">1</span>, l2 + <span class="number">1</span>, l2 + numleft);<span class="comment">//注意这里算法</span></span><br><span class="line">    node[pre[l2]].lc = <span class="built_in">build</span>(x + <span class="number">1</span>, r1, l2 + numleft+<span class="number">1</span>, r2);</span><br><span class="line">    <span class="keyword">return</span> pre[l2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; mid[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; pre[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">shuchu</span>(pre[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>    
<h2 id="L2-032彩虹瓶"><a href="#L2-032彩虹瓶" class="headerlink" title="L2-032彩虹瓶"></a>L2-032彩虹瓶</h2><p>我真的心态炸了，又是栈，狗东西，又写一小时！！！！！还只有18分！！！！！还是看了大佬错因！！！！！   </p>
<h3 id="啊啊啊啊啊啊啊啊啊啊"><a href="#啊啊啊啊啊啊啊啊啊啊" class="headerlink" title="啊啊啊啊啊啊啊啊啊啊"></a>啊啊啊啊啊啊啊啊啊啊</h3><p>我是不是不适合学这个啊？？？我最后都对自己的c语言基本功产生怀疑了。好不容易找到错误样例，我调啊调，到底是哪段代码不干净，原来nmd是输入不干净啊啊啊啊啊啊啊啊啊！！！是谁随读随用还break……累了，随便吧。<br>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> color, h, n, i;</span><br><span class="line">	cin &gt;&gt; color &gt;&gt; h &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> b = <span class="number">1</span>, c[<span class="number">1001</span>];</span><br><span class="line">		stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; color; i++)</span><br><span class="line">			cin &gt;&gt; c[i];<span class="comment">//一定要用数组先储存再判断</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; color; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (c[i] == b)<span class="comment">//如果是当前需要的颜色</span></span><br><span class="line">			&#123;</span><br><span class="line">				b++;<span class="comment">//这里决策很重要。装了一次后再看货架</span></span><br><span class="line">				<span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() == b) &#123; s.<span class="built_in">pop</span>(); b++; &#125;<span class="comment">//看一下栈顶是不是当前要装填的，如果是，则取下来装填</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				s.<span class="built_in">push</span>(c[i]);<span class="comment">//放在货架上</span></span><br><span class="line">				<span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; h) <span class="keyword">break</span>; <span class="comment">//超出容量直接结束</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (b &lt; color + <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;<span class="comment">//b&lt;color + 1说明没装完</span></span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种题我老捋不清逻辑。题目里其实有给。自己写的时候我把看货架和判断当前搞成并列关系了。事实上当前的可以装再看货架更对，当前的不能装货架上的也装不了。货架上拿下来一个以后要循环的看看后面的。我自己写的时候没有，直接push进去当前的。这个逻辑不对。我真的好讨厌模拟。。。。。</p>
<h2 id="L2-041-插松枝"><a href="#L2-041-插松枝" class="headerlink" title="L2-041 插松枝"></a>L2-041 插松枝</h2><p>16分code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,k,now=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> w[<span class="number">1004</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;v.<span class="built_in">size</span>();i++)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;v[i];</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    now=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>()&amp;&amp;s.<span class="built_in">top</span>()&lt;=now)<span class="comment">//栈顶ok</span></span><br><span class="line">        &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            <span class="keyword">if</span>(v.<span class="built_in">size</span>()==k)</span><br><span class="line">                <span class="built_in">fx</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                now=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w[i]&lt;=now)&#123;<span class="comment">//队列ok</span></span><br><span class="line">            v.<span class="built_in">push_back</span>(w[i]);</span><br><span class="line">            <span class="keyword">if</span>(v.<span class="built_in">size</span>()==k)</span><br><span class="line">                <span class="built_in">fx</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                now=w[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//队列不ok</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()==m)&#123;</span><br><span class="line">                <span class="built_in">fx</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(w[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v.<span class="built_in">size</span>())<span class="built_in">fx</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种题最好现在草纸上捋捋逻辑。最后调细节。而且大概拿不到全分，别的情况根本想不到</p>
<h2 id="L2-042-老板的作息表"><a href="#L2-042-老板的作息表" class="headerlink" title="L2-042 老板的作息表"></a>L2-042 老板的作息表</h2><p>我的破烂19分代码：至今没觉得哪错了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ak[<span class="number">1000000</span>];</span><br><span class="line">string s,s1;</span><br><span class="line"><span class="type">char</span> op;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuchu</span><span class="params">(<span class="type">int</span> fro,<span class="type">int</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c,d,e,f;</span><br><span class="line">    a=fro/<span class="number">3600</span>;</span><br><span class="line">    b=(fro%<span class="number">3600</span>)/<span class="number">60</span>;</span><br><span class="line">    c=fro%<span class="number">60</span>;</span><br><span class="line">    d=src/<span class="number">3600</span>;</span><br><span class="line">    e=(src%<span class="number">3600</span>)/<span class="number">60</span>;</span><br><span class="line">    f=src%<span class="number">60</span>;</span><br><span class="line">    string aa=<span class="string">&quot;&quot;</span>,bb=<span class="string">&quot;&quot;</span>,cc=<span class="string">&quot;&quot;</span>,dd=<span class="string">&quot;&quot;</span>,ee=<span class="string">&quot;&quot;</span>,ff=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">10</span>)aa+=<span class="string">&quot;0&quot;</span>;aa+=<span class="built_in">to_string</span>(a);</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">10</span>)bb+=<span class="string">&quot;0&quot;</span>;bb+=<span class="built_in">to_string</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(c&lt;<span class="number">10</span>)cc+=<span class="string">&quot;0&quot;</span>;cc+=<span class="built_in">to_string</span>(c);</span><br><span class="line">    <span class="keyword">if</span>(d&lt;<span class="number">10</span>)dd+=<span class="string">&quot;0&quot;</span>;dd+=<span class="built_in">to_string</span>(d);</span><br><span class="line">    <span class="keyword">if</span>(e&lt;<span class="number">10</span>)ee+=<span class="string">&quot;0&quot;</span>;ee+=<span class="built_in">to_string</span>(e);</span><br><span class="line">    <span class="keyword">if</span>(f&lt;<span class="number">10</span>)ff+=<span class="string">&quot;0&quot;</span>;ff+=<span class="built_in">to_string</span>(f);</span><br><span class="line">    cout&lt;&lt;aa&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;bb&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;cc&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dd</span><br><span class="line">&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;ee&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;ff&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//if(n==0)cout&lt;&lt;&quot;00:00:00 - 23:59:59&quot;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;op&gt;&gt;s1;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>,d=<span class="number">0</span>,e=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">        a=(s[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+s[<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//13</span></span><br><span class="line">        b=(s[<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+s[<span class="number">4</span>]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//00</span></span><br><span class="line">        c=(s[<span class="number">6</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+s[<span class="number">7</span>]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//00</span></span><br><span class="line">        d=(s1[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+s1[<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//18</span></span><br><span class="line">        e=(s1[<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+s1[<span class="number">4</span>]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//00</span></span><br><span class="line">        f=(s1[<span class="number">6</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+s1[<span class="number">7</span>]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//00</span></span><br><span class="line">        sum1=a*<span class="number">3600</span>+b*<span class="number">60</span>+c;</span><br><span class="line">        sum2=d*<span class="number">3600</span>+e*<span class="number">60</span>+f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=sum1;i&lt;sum2;i++)</span><br><span class="line">            ak[i]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> f=<span class="number">0</span>;<span class="comment">//零标志</span></span><br><span class="line">    <span class="type">int</span> fro=<span class="number">0</span>,src=<span class="number">0</span>;<span class="comment">//左区间 右</span></span><br><span class="line">    <span class="type">int</span> q=<span class="number">0</span>;<span class="comment">//输出标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3600</span>*<span class="number">24</span>;i++)<span class="comment">//000000-235959</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f&amp;&amp;!ak[i])&#123;</span><br><span class="line">            f=<span class="number">1</span>;</span><br><span class="line">            fro=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f&amp;&amp;ak[i])&#123;</span><br><span class="line">            f=<span class="number">0</span>;<span class="comment">//还原0标</span></span><br><span class="line">            src=i;</span><br><span class="line">            q=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q)&#123;</span><br><span class="line">            <span class="built_in">shuchu</span>(fro,src);</span><br><span class="line">            q=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fro&gt;src||!fro)<span class="built_in">shuchu</span>(fro,<span class="number">3600</span>*<span class="number">24</span><span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于柳神的15行写完，我的评价是。。。也许真的不是一个物种吧。<br>所以当时为什么没想到sort呢。还有set+pair按第一个键排序，升序。</p>
<h2 id="L2-043-龙龙送外卖"><a href="#L2-043-龙龙送外卖" class="headerlink" title="L2-043 龙龙送外卖"></a>L2-043 龙龙送外卖</h2><p>一眼没思路，柳婼小姐姐说</p>
<h2 id="L2-044-大众情人"><a href="#L2-044-大众情人" class="headerlink" title="L2-044 大众情人"></a>L2-044 大众情人</h2><p>我真崩溃了，scanf有时候真的是个很好的读入东西，，，，<br><img src="/../someimage/image-27.png"><br>是floyd，您就洛吧，一落一个不吱声。我至今仍不知道为什么k在最外层。<br>ac code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">505</span>][<span class="number">505</span>],b,c;</span><br><span class="line"><span class="type">char</span> sex[<span class="number">505</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">505</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">505</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(i!=j)</span><br><span class="line">                a[i][j]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;sex[i]&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d&quot;</span>,&amp;b,&amp;c);</span><br><span class="line">            a[i][b]=c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]&gt;a[i][k]+a[k][j])</span><br><span class="line">                    a[i][j]=a[i][k]+a[k][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sex[j]!=sex[i])&#123;<span class="comment">//统计他到所有异性max距离</span></span><br><span class="line">                maxn=<span class="built_in">max</span>(maxn,a[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i]=maxn;<span class="comment">//统计完</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每个人最远距离统计完毕</span></span><br><span class="line">    <span class="comment">//统计大众情人</span></span><br><span class="line">    <span class="type">int</span> ans1=<span class="number">0x3f3f3f3f</span>,ans2=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sex[i]==<span class="string">&#x27;F&#x27;</span>)ans1=<span class="built_in">min</span>(ans1,ans[i]);</span><br><span class="line">        <span class="keyword">else</span> ans2=<span class="built_in">min</span>(ans2,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//男女两方大众情人标准统计完毕</span></span><br><span class="line">    <span class="comment">//找人</span></span><br><span class="line">    <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sex[i]==<span class="string">&#x27;F&#x27;</span>&amp;&amp; ans[i]==ans1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">            cout&lt;&lt;i;</span><br><span class="line">            f=<span class="number">1</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;cout&lt;&lt;endl;</span><br><span class="line">    f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sex[i]==<span class="string">&#x27;M&#x27;</span>&amp;&amp; ans[i]==ans2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!f)&#123;</span><br><span class="line">            cout&lt;&lt;i;</span><br><span class="line">            f=<span class="number">1</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>蒟蒻的2024蓝桥杯省赛之旅</title>
    <url>/2024/04/15/2024lanqiao/</url>
    <content><![CDATA[<h2 id="A艺术与篮球"><a href="#A艺术与篮球" class="headerlink" title="A艺术与篮球"></a>A艺术与篮球</h2><p>我真服了。回来后对着答案调都调不出来。。。。。黄豆流汗送给自己。考场上写了小四十分钟。丢东拉西的，就像被某种东西附体了一样。变成弱智了。考场上3202，回来后再写3230,答案3228。md都是玄学是吧，然后发现该死的闰年判错了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="type">int</span> month[] = &#123; <span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span> &#125;;</span><br><span class="line"><span class="type">int</span> ans,tmp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2000</span>; i &lt;= <span class="number">2024</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((i % <span class="number">100</span>) &amp;&amp; (!(i % <span class="number">4</span>)) || !(i % <span class="number">400</span>))month[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line">		<span class="keyword">else</span> month[<span class="number">2</span>] = <span class="number">28</span>;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; month[2] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">12</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= month[j]; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">2024</span> &amp;&amp; j == <span class="number">4</span> &amp;&amp; k == <span class="number">14</span>)<span class="keyword">goto</span> end;</span><br><span class="line">				string ss = <span class="built_in">to_string</span>(i);</span><br><span class="line">				<span class="keyword">if</span> (j &lt; <span class="number">10</span>)ss += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				ss += <span class="built_in">to_string</span>(j);</span><br><span class="line">				<span class="keyword">if</span> (k &lt; <span class="number">10</span>)ss += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				ss += <span class="built_in">to_string</span>(k);</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; ss.<span class="built_in">length</span>(); d++)</span><br><span class="line">					tmp += a[ss[d] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">				<span class="keyword">if</span> (tmp &gt; <span class="number">50</span>)ans++;</span><br><span class="line">				tmp = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	end: cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;   </span><br><span class="line"></span><br><span class="line">还有件事，考场上devc不让用to_string？我明明include string了也不行。可能是语言版本问题？</span><br><span class="line">## B五子棋</span><br><span class="line">我当时直接自信dfs，但是没有发现太慢了。我枚举棋盘上可能发生的所有情况，每个人所有走法，这个好像是<span class="number">25</span>！。<span class="number">25</span>！是<span class="number">15511210043330985984000000</span>。我考试时特意写了个程序算了一下，当时算的是十位数。为什么呢？因为没开longlong...蛤蛤。但是不用考虑走法的，其实只要枚举棋盘所有结果就好。不同路径可能得到相同方案的。我太搞笑了。</span><br><span class="line">蓝桥的填空看起来简单，其实真的很考验代码功底。真的无从验证对错，还不能加样例。只能审视程序  </span><br><span class="line">accode:</span><br><span class="line">```cpp</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn  (1 &lt;&lt; 25)-1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> s = <span class="number">0</span>,s2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">			s += (a &gt;&gt; (i * <span class="number">5</span> + j) &amp; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="number">0</span> || s == <span class="number">5</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">			s2 += (a &gt;&gt; (j * <span class="number">5</span> + i) &amp; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (s2 == <span class="number">0</span> || s2 == <span class="number">5</span>) &#123;  <span class="comment">//cout &lt;&lt; 1 &lt;&lt; endl;</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (((a &gt;&gt; <span class="number">0</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">6</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">12</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">18</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">24</span> &amp; <span class="number">1</span>)) == <span class="number">5</span> || ((a &gt;&gt; <span class="number">0</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">6</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">12</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">18</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">24</span> &amp; <span class="number">1</span>)) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (((a &gt;&gt; <span class="number">4</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">8</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">12</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">16</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">20</span> &amp; <span class="number">1</span>)) == <span class="number">5</span> || ((a &gt;&gt; <span class="number">4</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">8</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">12</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">16</span> &amp; <span class="number">1</span>) + (a &gt;&gt; <span class="number">20</span> &amp; <span class="number">1</span>)) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxn ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">25</span>; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span>)num++;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (num == <span class="number">13</span> &amp;&amp; !<span class="built_in">check</span>(i))ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;<span class="comment">//3126376</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C训练士兵"><a href="#C训练士兵" class="headerlink" title="C训练士兵"></a>C训练士兵</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, s,tmp1,tmp2,maxn,l,r;</span><br><span class="line">PII p[<span class="number">100050</span>];<span class="comment">//p c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jis</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = a * s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p[i].second &gt; a)sum += (p[i].second - a) * p[i].first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; p[i].first &gt;&gt; p[i].second;</span><br><span class="line">		maxn = <span class="built_in">max</span>(maxn, p[i].second);</span><br><span class="line">	&#125;</span><br><span class="line">	r = maxn;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = (l + r+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">jis</span>(mid) &gt; <span class="built_in">jis</span>(mid + <span class="number">1</span>))l = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">jis</span>(l) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考场上的二分代码。不知道对不对。二次函数也算有二段性吧，，对吧。mid+1的思想是看斜率。。。说实话是我考场上发明的，不知道大数据行不行。。。  </p>
<h2 id="D团建"><a href="#D团建" class="headerlink" title="D团建"></a>D团建</h2><p>暴力是10*11会超时。我当时想了一下用空间换时间。其实我最开始以为是书上dp，瞪眼半个小时没敢开始做，哈哈哈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> wn[<span class="number">200050</span>], wm[<span class="number">200050</span>];</span><br><span class="line"><span class="type">int</span> n, m,tmp1,tmp2,ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vn[<span class="number">200050</span>],vm[<span class="number">200050</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root1,<span class="type">int</span> root2,<span class="type">int</span> lev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans = <span class="built_in">max</span>(ans, lev);</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;a;<span class="comment">//往map插键值省空间。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vn[root1].<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[wn[vn[root1][i]]] = i; <span class="comment">//在孩子中的相对位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vm[root2].<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a.<span class="built_in">find</span>(wm[vm[root2][i]]) != a.<span class="built_in">end</span>())<span class="comment">//n里有这个权值</span></span><br><span class="line">			<span class="built_in">dfs</span>(vn[root1][a[wm[vm[root2][i]]]], vm[root2][i],lev + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; wn[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		cin &gt;&gt; wm[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; tmp1&gt;&gt; tmp2;</span><br><span class="line">		vn[tmp1].<span class="built_in">push_back</span>(tmp2);</span><br><span class="line">		vn[tmp2].<span class="built_in">push_back</span>(tmp1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; tmp1 &gt;&gt; tmp2;</span><br><span class="line">		vm[tmp1].<span class="built_in">push_back</span>(tmp2);</span><br><span class="line">		vm[tmp2].<span class="built_in">push_back</span>(tmp1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果根节点权值相等</span></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还没调出来。我的思路又绕了，老认不清哪存了什么，对应关系太乱了。应该在map里直接存这个节点名，而不是相对位置，还要算……还要注意vis，可以开数组，可以带着父亲传参dfs。太乱了先不调了</p>
]]></content>
  </entry>
  <entry>
    <title>EduOJ部署操作</title>
    <url>/2024/03/24/EduOJ/</url>
    <content><![CDATA[<h2 id="关于eduoj部署操作总览："><a href="#关于eduoj部署操作总览：" class="headerlink" title="关于eduoj部署操作总览："></a>关于eduoj部署操作总览：</h2><p>网站地址：<a href="https://github.com/EduOJ">https://github.com/EduOJ</a><br>操作步骤：<br>1.将网站中的frontend，backend，judgeServer拉取到虚拟机EduOJ文件夹下。（虚拟机内需要有的环境：docker，go（后端），nodejs，yarn（前端））<br>1.1 配置虚拟机环境：VMware，root下执行  </p>
<pre><code>#安装docker
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc
# Add the repository to Apt sources:
echo   &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
 $(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;) stable&quot; |   sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
#拉取minio镜像
docker pull quay.io/minio/minio 
docker pull postgres:12
docker exec -it postgres bash
docker pull postgres:12
docker pull redis:5.0
docker run --name postgres --restart always -e POSTGRES_PASSWORD=123 -p 5432:5432 -d postgres:12 #创建minio容器
docker run -p 9000:9000 -p 9001:9001 -d --restart always --name minio -e &quot;MINIO_ROOT_USER=minio&quot; -e &quot;MINIO_ROOT_PASSWORD=minio123&quot; quay.io/minio/minio server /data --console-address &quot;:9001&quot;
docker run -d -p 6379:6379 --name redis --restart always redis:5.0
docker exec -it postgres createdb -U postgres eduoj #创建一个叫eduoj的数据库
docker exec -it postgres psql -U postgres #在内启动psql交互，使用户能进行数据库操作
</code></pre>
<p>1.2将网站中的frontend，backend，judgeServer拉取到虚拟机EduOJ文件夹下。</p>
<pre><code>cd eduoj
git clone https://github.com/EduOJ/backend.git
git clone https://github.com/EduOJ/frontend.git
git clone https://github.com/EduOJ/judgeServer.git
go build .
cp config.yml.example config.yml
vi config.yml   #这里需要下载vim
</code></pre>
<p>1.3 修改其中的</p>
<pre><code>database:
   dialect: postgres
   uri: host=localhost port=5432 user=postgres dbname=eduoj password=123
storage:
   endpoint: 192.168.168.130:9000 #ip改成你的虚拟机ip
   access_key_id: minio
   access_key_secret: minio123
</code></pre>
<p>2.配置前端文件</p>
<pre><code>cd frontend
yarn
cp src/config/config.example.js src/config/config.js
</code></pre>
<p>3.注册用户并给超级管理员权限</p>
<pre><code>$ ./backend permission
gr &lt;username&gt; admin
</code></pre>
<p>4.修改评测机配置文件</p>
<pre><code>#在评测机仓库执行
cp config.yml.example config.yml
vi config.yml
#修改评测机配置文件
backend:
  endpoint: http://192.168.168.130:8080/judger #ip改成你的虚拟机ip

user:
  build: build_user
  run: run_user

auth:
    name: sssbo  #随便
    token: aaaaa #和后端配置文件中的token改为一致

path:
    scripts: ./data/scripts  #注意
  test_cases: ./data/test_cases
</code></pre>
<p>5.配置评测机数据库<br>添加语言 在评测机（judgerServer）的仓库里新建zipped文件夹。然后运行example&#x2F;zipall.py（不要用root，普通用户就好）：<code>python3 zipall.py</code>.<br>之后把打包出来的默认语言的编译&#x2F;运行脚本（在zipped里）上传到minio中scripts的bucket中。 然后连接到数据库，手动在scripts和languages表内插入条目。scripts表中file_name和name都写压缩文件的名字(没有.zip)即可。</p>
<p>6.启动网页：<br>前端：<code>yarn serve</code><br>后端：<code>go run .</code><br>     <code>go run . serve</code><br>评测机：<code>docker run -d -v</code>pwd<code>/config.yml:/config.yml eduoj/judger:latest</code>(这个每运行一次建立一个docker镜像。去掉-d看log）</p>
]]></content>
  </entry>
  <entry>
    <title>数字逻辑知识点总结</title>
    <url>/2023/10/15/Untitled-1/</url>
    <content><![CDATA[<p>希希很讨厌这门课orz，很玄妙  </p>
<ol>
<li>根据真值表画卡诺图   <span id="more"></span></li>
</ol>
<p>真值表里是1，对应卡诺图也就填1.比如011(3)是1，那么卡诺图里的011也就是1.真值表里是0同理。 真值表里变量顺序无所谓<br><img src="/../someimage/knt.png"><br><strong>AB为最高位！！</strong>  </p>
<ol>
<li>根据最小项画卡诺图<br>最小项m（1，3，4），对应的位置表格里填1，最大项反之   </li>
<li>卡诺图直接化简出与或式</li>
<li>门级结构描述f&#x3D;x2~x3+x1x3   <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line"><span class="keyword">input</span> x3,</span><br><span class="line"><span class="keyword">input</span> x2,</span><br><span class="line"><span class="keyword">input</span> x1,</span><br><span class="line"><span class="keyword">output</span> f</span><br><span class="line">);</span><br><span class="line"><span class="keyword">wire</span> w1,w2;<span class="comment">//连出的线</span></span><br><span class="line"><span class="keyword">and</span> a1(w1,x2,~x3),a2(w2,x3,x1);</span><br><span class="line"><span class="keyword">or</span> o1(f,w1,w2);</span><br><span class="line"><span class="keyword">endmodule</span>;</span><br></pre></td></tr></table></figure></li>
<li>数据流描述（不关心门的构造，只管描述表达式）   <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tm(</span><br><span class="line"><span class="keyword">input</span> x1,</span><br><span class="line"><span class="keyword">input</span> x2,</span><br><span class="line"><span class="keyword">input</span> x3,</span><br><span class="line"><span class="keyword">output</span> f</span><br><span class="line">);</span><br><span class="line"><span class="keyword">assign</span> f=(~x3&amp;x2)|(x3&amp;x1);<span class="comment">//一定有assign，是重点,好像括号没有太大的必要</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
<li>行为描述（模块）<br>用到always之类的块</li>
<li>2421码<br>从左到右，第一位权值为2，第二位的权值为4，第三位的权值为2，第四位的权值为1。 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> zh8421_2421(in,out,err);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>]in;<span class="comment">//4位，不写则为一位</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]out;</span><br><span class="line">    <span class="keyword">output</span> err;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]out;<span class="comment">//reg表示被定义的信号将用在always模块内</span></span><br><span class="line">    <span class="keyword">reg</span> err;<span class="comment">//四个口也可以写在上面括号里</span></span><br><span class="line">        <span class="keyword">always</span>@(in)</span><br><span class="line">            <span class="keyword">if</span>(in&gt;<span class="number">4&#x27;b1001</span>)<span class="comment">//&gt;9,&#x27;b表示二进制，&#x27;h十六进制</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                out=<span class="number">0</span>;</span><br><span class="line">                err=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(in&gt;<span class="number">4&#x27;b0100</span>)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                out=in+<span class="number">4&#x27;b0110</span>;</span><br><span class="line">                err=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                out=in;</span><br><span class="line">                err=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
<li>一些运算符<br>&amp;按位与<br>&amp;&amp;逻辑与<br>位拼接{}<br>b[3]b为4位向量的<strong>第一位</strong>，最左边这个-&gt;口口口口,还有b[2],b[1]……注意和数组是反的  </li>
<li>一些奇怪的名词  <ol>
<li>半加器 指对输入的两个一位二进制数相加（A与B），输出<strong>一个结果位（SUM）和进位（C）</strong>，没有进位的输入加法器电路，是一个实现一位二进制数的加法电路  </li>
<li>全加器 输入两个二进制位和一个进位，一起运算后输出和和进位<br> <img src="/..%5Csomeimage%5Cssk.png"></li>
<li>全减器<br> <img src="/image-18.png" alt="Alt text"><br> bo的a取非，其他一样。接受来自低位的借位，输出向高位的借位。</li>
</ol>
</li>
<li>一些逻辑式化简规则<br><img src="/..%5Csomeimage%5C707.jpg"></li>
<li>逻辑险象<br>也称逻辑冒险。 两个输入信号同时向相反方向的逻辑电平跳变的现象（即一个由1- &gt; 0， 另一个从0 -&gt; 1），称为竞争。<br>因竞争导致在输出端可能产生尖峰脉冲的现象，称为冒险。<img src="/..%5Csomeimage%5C81ca.png"><br>判断逻辑险象：出现相切的卡诺图，或式中A和A’同时出现。<img src="/..%5Csomeimage%5C732.png"><img src="/..%5Csomeimage%5C142.png"><br>ps消除时也画包含切线的最大圈！</li>
<li>典型代码类型<br>格雷码：二进制转格雷码要用三个异或</li>
<li>触发器<br>很抽象。<br>同步置位:上升沿来临才赋值<br>异步：异步置位与复位是与时钟无关的。把它们列入always块的事件控制括号内就能触发always块的执行。<br><img src="/image.png" alt="Alt text"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//边沿JK触发器。同步</span></span><br><span class="line"><span class="keyword">module</span> jk_trigger(clk, j, k, q);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">input</span> clk, j, k;</span><br><span class="line"><span class="keyword">output</span> q;</span><br><span class="line"><span class="keyword">reg</span> q;</span><br><span class="line"><span class="keyword">wire</span> qb;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)       <span class="comment">//时钟上升沿到来时，判断jk的值</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">case</span>(&#123;j,k&#125;)</span><br><span class="line">	<span class="number">2&#x27;b00</span>: q &lt;= q;       <span class="comment">//如果&#123;j,k&#125;=00，则触发器处于保持状态</span></span><br><span class="line">	<span class="number">2&#x27;b01</span>: q &lt;= <span class="number">1&#x27;b0</span>;    <span class="comment">//如果&#123;j,k&#125;=01，则触发器置1</span></span><br><span class="line">	<span class="number">2&#x27;b10</span>: q &lt;= <span class="number">1&#x27;b1</span>;    <span class="comment">//同理10，清零</span></span><br><span class="line">	<span class="number">2&#x27;b11</span>: q &lt;= ~q;      <span class="comment">//11,翻转</span></span><br><span class="line">	<span class="keyword">default</span>: q &lt;= q;</span><br><span class="line">	<span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">assign</span> qb = ~q;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
D画波形的题：锁存器在有效时与输入D保持一致。触发器在有效边沿来临时与来临前的D值保持一致。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>第一次acm</title>
    <url>/2023/09/17/acm-1/</url>
    <content><![CDATA[<p>我意识到acm是真正意义上智商的比拼。想要找到能一起讨论题目的人先得看懂题目。只有当你的水平远远高于环境时你的环境才有可能改变。主动改变环境只是徒有其表，内里没有改变，只会不欢而散。<br>用不欢而散来形容今天很合适，我早就预想到了今天的结果。因为我耐不住寂寞  </p>
<span id="more"></span>  
<p>无法在悄无声息中改变自己。我是一个很虚浮的人<br>总结一下情况吧。北工大一共有十个队，我们是倒数123的位置（可能真是倒1？）有点丢人。封榜时我们只写出一道题，第一名写出6道题（一共12道）。记录一下情况吧</p>
<h2 id="A-去重-归并"><a href="#A-去重-归并" class="headerlink" title="A:去重+归并"></a>A:去重+归并</h2><p>题目不难，难在理解题意和排序上。人多容易打乱思路，加上刚开始考试时紧张，代码写的有点恶心。我是最开始做这个题的，结果一直做到了离结束还有四十分钟的时候。中途ghj还写了完整的代码但超时了（他完全不会stl）我最后写出了代码但是wa，还是ghj想了个样例给我说新建一个map才搞出来。如果就凭我自己的话大概也只能做出来一道吧</p>
<h2 id="B：string"><a href="#B：string" class="headerlink" title="B：string"></a>B：string</h2><p>大佬的玩具，整个百工没人做出来。ghj想了一个小时这题，我笑死</p>
<h2 id="D-无向图"><a href="#D-无向图" class="headerlink" title="D:无向图"></a>D:无向图</h2><p>我看不懂题目。。我觉得就是补全所有边但是wa，队友也不会<br>9.19更新：wa了一天一夜后，花重金请大佬帮忙改了代码。大佬果然是大佬  </p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
vector&lt;int&gt;v[1000006];
int fa[1000006];
int n, m, a, b;
int x1, x2;
bool flag;
long long eg[1000006];//散列化记边
long long vt[1000006];//散列化记点
long long ans;

int fin(int now) &#123;
    if (fa[now] != now)
        return fa[now] = fin(fa[now]);
    else
        return now;
&#125;

void connect(int A, int B)
&#123;
    int a = fin(A), b = fin(B);
    if (a != b) &#123;
        fa[a] = fa[b] = min(a, b);
    &#125;
&#125;

int main()
&#123;
    //freopen(&quot;text_input.txt&quot;, &quot;r&quot;, stdin);
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)
        fa[i] = i;
    for (int i = 0; i &lt; m; i++)
    &#123;
        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
        v[a].push_back(b);
        v[b].push_back(a);
        connect(a, b);
    &#125;//建图
    for (int i = 1; i &lt;= n; i++)
    &#123;
        fin(i);
    &#125; 
    for (int i = 1; i &lt;= n; i++)
        eg[fa[i]] += (long long)v[i].size();
    for (int i = 1; i &lt;= n; i++)
        eg[i] /= 2LL;
    for (int i = 1; i &lt;= n; i++)
        vt[fa[i]]++;
    for (int i = 1; i &lt;= n; i++)
        if (vt[i])
            if (eg[i] &lt; (vt[i] * (vt[i] - 1)) / 2)
                ans += ((vt[i] * (vt[i] - 1)) / 2 - eg[i]);
    if (!ans)
    &#123;
        sort(vt + 1, vt + 1 + n);
        for (int i = 1; i &lt;= n; i++)
        &#123;
            if (vt[i] != 0)
            &#123;
                x1 = vt[i];
                x2 = vt[i + 1];
                break;
            &#125;
        &#125;
        ans = x1 * x2;
    &#125;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>咱就是说别在百度上下搜算法。。。害人害己。。。。并查集find和connect函数就是不能少啊。。。我发现我老是太喜欢投机取巧了。大佬的代码只挑一篇自己喜欢的看，别的不理解也无所谓，算法复杂的东西一律掠过，只接受自己想接受的……真的太高傲了，我对待学问的态度很傲慢。而且从小到大一直如此，尤其是数学。</p>
<h2 id="J-计算几何"><a href="#J-计算几何" class="headerlink" title="J:计算几何"></a>J:计算几何</h2><p>我瞎想了一个贪心但是差0.01，后来发现方法不对，很崩溃</p>
<h2 id="L-签到题"><a href="#L-签到题" class="headerlink" title="L:签到题"></a>L:签到题</h2><p>翔哥签的，我没看。不到半小时就做出来的题。也是我们前四小时唯一做出来的一题<br>怎么说呢。谨以此文纪念我的队友。三个人一起敲代码很有意思。如果他们会的比我多就更好了。希望下次还能聚在一起。但是我感觉下次他们可能不愿意来了。但是我还是很想打第二场，我觉得发挥的一定能比这次好。不知道为什么。<br>为什么没有大佬带带我啊……  </p>
<h2 id="情况总结"><a href="#情况总结" class="headerlink" title="情况总结"></a>情况总结</h2><p>百工a4题排在中间位置。5题有望进区域赛。2题垫底。说到这里我就得感谢一下ysm了，我问他去年的信息他回答的模模糊糊的，说什么每届不一样。害得我问他做出一半多不多。。显得我像个小丑。这种数据不能实实在在的告诉我吗。。。还有我的队友好像过于乐观的估计了情况。只写出了两题告诉我他想死，他之前自己真的了解都不了解一下，我真的服气。我打的最好情况就是两道题。这已经是我预想中很好的结果了。只不过大家都比我想的厉害罢了。队友能不能别瞎交题啊<br>越写怨气越大了……应该多反省自己，为什么这么菜……但是J和D我真的尽力了。还有A。我也是头一次感觉到了我可能确实不太适合这个游戏<br>还有下次吗？</p>
]]></content>
  </entry>
  <entry>
    <title>关于起岸希的书单</title>
    <url>/2023/07/20/book/</url>
    <content><![CDATA[<p>众所周知，起岸希还是很爱读书的，她把她从大学一年级起读过的书整理了一下，有的没有读完，不过会努力更新进度  </p>
<h2 id="关于计算机"><a href="#关于计算机" class="headerlink" title="关于计算机"></a>关于计算机</h2><h3 id="c-primer-plus"><a href="#c-primer-plus" class="headerlink" title="c primer plus"></a>c primer plus</h3><span id="more"></span>    
<p><img src="/../someimage/cp.jpg"><br>我的c语言入门经典书~学校讲的稀烂，所有的计算机语言特性和c语言基础都是跟他学的，很厚，讲的很细致，很适合入门啃。我当时啃了两个月，期间的每一天都很快乐。  </p>
<h3 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h3><p><img src="/../someimage/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.jpg"><br>看了前2章，对整个计算机架构有个基本的了解，第三章数学比较多，含枯燥的公式论证</p>
<h3 id="算法竞赛入门经典"><a href="#算法竞赛入门经典" class="headerlink" title="算法竞赛入门经典"></a>算法竞赛入门经典</h3><p><img src="/../someimage/%E7%AE%97%E6%B3%95.jpg"><br>人称紫书，看了一半很有收获，感觉里面的oi类型较为古早，但是有很棒的思路，希望他能带我打进区域赛（  </p>
<h3 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h3><p><img src="/../someimage/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.jpg"><br>我看完的第一本算法书，也是我的算法入门书，全书小500页，讲的通俗易懂，知识点覆盖不全  </p>
<h3 id="网络是怎样连的"><a href="#网络是怎样连的" class="headerlink" title="网络是怎样连的"></a>网络是怎样连的</h3><p><img src="/../someimage/%E7%BD%91%E7%BB%9C.jpg"><br>我的互联网入门书，算是我看过的最容易懂的网络书了。推荐给大家入门  </p>
<h3 id="图解TCP-x2F-IP"><a href="#图解TCP-x2F-IP" class="headerlink" title="图解TCP&#x2F;IP"></a>图解TCP&#x2F;IP</h3><p><img src="/../someimage/%E5%9B%BE%E8%A7%A3.jpg"><br>薄书，比上一本难且枯燥一些，推荐有一些基础再看，目前看了20%左右吧  </p>
<h3 id="挑战程序设计竞赛"><a href="#挑战程序设计竞赛" class="headerlink" title="挑战程序设计竞赛"></a>挑战程序设计竞赛</h3><p><img src="/../someimage/%E6%8C%91%E6%88%98.jpg"><br>人称白书，和紫书一起看的，大家说这本比紫书简单但是我不觉得。有些难点的算法和数据结构，比如状压dp，st表这种。跳着看的  </p>
<h3 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h3><p><img src="/../someimage/%E6%B7%B1%E5%85%A5.jpg"><br>计算机界有名的大厚书，并且是大二要上的一门课，对各种现象解释的非常底层和详尽。由于有对大书的畏惧，目前看了10%吧   </p>
<h3 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h3><p><img src="/../someimage/%E9%9D%A2%E5%90%91.jpg"><br>我大一上特爱这本书，带我入门了面向对象编程，写的巨好，把我看同类型的书觉得很难的东西春风化雨，写的特别好理解。是我看过的教c++面向对象里最好的书了，看了1.5遍…（ps但是依旧没有拯救我的java……  </p>
<h2 id="关于人生-x2F-生活"><a href="#关于人生-x2F-生活" class="headerlink" title="关于人生&#x2F;生活"></a>关于人生&#x2F;生活</h2><h3 id="影响力"><a href="#影响力" class="headerlink" title="影响力"></a>影响力</h3><p><img src="/../someimage/%E5%BD%B1%E5%93%8D.jpg"><br>会学到一些小技巧，比如目的是7就开口要10这种</p>
<h3 id="亲密关系"><a href="#亲密关系" class="headerlink" title="亲密关系"></a>亲密关系</h3><p>有很多有意思的调查  </p>
<h3 id="你不可不知的人性"><a href="#你不可不知的人性" class="headerlink" title="你不可不知的人性"></a>你不可不知的人性</h3><p><img src="/../someimage/%E4%BD%A0%E4%B8%8D.jpg"><br>刘庸的处事系列我都很喜欢，尤其是那本《我不是教你诈》，讲了好多令我叹为观止的人间套路……感觉看完这个系列后情商提高了  </p>
]]></content>
  </entry>
  <entry>
    <title>基于B树的图书管理系统</title>
    <url>/2023/05/26/btree/</url>
    <content><![CDATA[<h2 id="程序构思"><a href="#程序构思" class="headerlink" title="程序构思"></a>程序构思</h2><p>分为三个头文件：类头文件，函数实现头文件，源文件。源文件实现和用户的交互。<br>分为三个类：book btnode btree<br>分别存储  书对象  树节点  b树接口<br>一共六个操作：  </p>
<ol>
<li>采编入口  </li>
<li>清除库存  </li>
<li>借阅  </li>
<li>归还  </li>
<li>查询  </li>
<li>显示<br>每个操作两个函数，一个负责和b树的交互，一个和用户交互。</li>
</ol>
<span id="more"></span>  

<h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><ol>
<li>头文件源文件如何共享全局变量  </li>
<li>文件oi乱码</li>
<li>如何实现文件的更新</li>
<li>凹入表</li>
</ol>
<h3 id="头文件源文件如何共享全局变量"><a href="#头文件源文件如何共享全局变量" class="headerlink" title="头文件源文件如何共享全局变量"></a>头文件源文件如何共享全局变量</h3><p>用extern在头文件中声明变量，在cpp中定义（赋值）变量<br>本来想定义一个全局树对象，后来发现还是不行。。。就改传参了。类A中有两个函数a(),b()，a中调用b居然也要以对象.的形式，真麻烦。。。。</p>
<h3 id="文件oi乱码"><a href="#文件oi乱码" class="headerlink" title="文件oi乱码"></a>文件oi乱码</h3><p><img src="/../someimage/hao.png"><br>咱就是说电脑是GBK，但是文件是UTF-8，将文件编码改为ANSI就行了<br><img src="/../someimage/le.png"></p>
<h3 id="凹入表"><a href="#凹入表" class="headerlink" title="凹入表"></a>凹入表</h3><p>之前看网上的凹入表图片没有头绪，后来发现不过是树的先序遍历……打印孩子换行，根据层数记算每个孩子前面的空格  </p>
<pre><code class="cpp">void travel(BTNodePosi a, int k)
&#123;
    if (a == NULL)return;//没有东西
    for (int cnt = 0; cnt &lt; k; cnt++)
        cout &lt;&lt; &quot;  &quot;;
    for (int i = 0; i &lt; a-&gt;key.size(); i++)
        if (i == 0)cout &lt;&lt; a-&gt;key[i];
        else cout &lt;&lt; &quot;,&quot; &lt;&lt; a-&gt;key[i];
    cout &lt;&lt; endl;
    for (int i = 0; i &lt; a-&gt;child.size(); i++)
        travel(a-&gt;child[i], k + 1);//下一层
&#125;
</code></pre>
<h2 id="写后感"><a href="#写后感" class="headerlink" title="写后感"></a>写后感</h2><p>这个程序最怪的是主函数中定义了一棵树，然后树类内部的操作函数还需要传树根的参，很诡异，也不知道哪里出了问题。因为借鉴的是c语言版，也不知道这个树实例化后怎么通过自己的函数直接改内部特性，好像可以this指针？<br>下了个大数据，4k本书调了一下，树没有问题，不过2-3树感觉没有用到b树过多的特性，速度方面应该还是挺慢的吧……</p>
]]></content>
  </entry>
  <entry>
    <title>关于clion配置</title>
    <url>/2023/04/14/clion/</url>
    <content><![CDATA[<p>起岸希一开始配置好了各种编译环境。但是出现<strong>运行小三角灰色，无法运行</strong> 的情况。<br>如图所示：<img src="/../someimage/1.png"><br>解决方法：<br>1.检查是否配置好编译环境   </p>
<span id="more"></span>  


<p><img src="/../someimage/2.png"><br>注意！buildtool那三排下面如果有个黄三角警告是不行的。可能需要手动选择。按图上的来就好啦~</p>
<p>2.环境配好了注意储存项目的路径必须是全英文。如果是全英文但是问题依旧没有解决你应该是把项目存c盘了。c盘路径“用户”显示的是“users”，我猜是因为这个。可以在D盘中新开一个文件夹，重新存项目，新开好的项目如果生成这样一个cmake文件就没有问题啦~<img src="/../someimage/3.png"></p>
]]></content>
  </entry>
  <entry>
    <title>基于c和easyx的游戏开发</title>
    <url>/2023/03/22/easyx/</url>
    <content><![CDATA[<h2 id="一开始我本来想开发一个像橙光一样的翻页阅读样式的小游戏，带剧情那种……结果，发现easyx的性能对这种游戏模式支持的并不好"><a href="#一开始我本来想开发一个像橙光一样的翻页阅读样式的小游戏，带剧情那种……结果，发现easyx的性能对这种游戏模式支持的并不好" class="headerlink" title="一开始我本来想开发一个像橙光一样的翻页阅读样式的小游戏，带剧情那种……结果，发现easyx的性能对这种游戏模式支持的并不好"></a>一开始我本来想开发一个像橙光一样的翻页阅读样式的小游戏，带剧情那种……结果，发现easyx的性能对这种游戏模式支持的并不好</h2><p>所以我最后向前人低头（不是），还是改作马里奥那种技巧交互式游戏吧……<br>但是！！！马里奥没有教程啊！b站上搜不到一个完整的教程……也没有一个完整的代码包可以自己拿来运行看看实现……不是缺这个头文件就是缺那个素材，导致我只能自造轮子（悲）<br>我的地图是用tiled做的，需要解析json文件，但是相关讲解视频b站上只找到一个，而且代码在我的机器上还跑不了（别问，问就是访问权限冲突），至于到底是怎么从jSON文件的一堆数字变成一块块的能运行出来的地图我也不知道啊！！<br>制作过程中遇到了很多问题，以下列了一个清单：  </p>
<span id="more"></span>

<ol>
<li>easyx的字符集问题  </li>
<li>如何实现链表文件存储  </li>
<li>如何实现链表排序（排行榜）  </li>
<li>单击实现翻页  </li>
<li>让messagebox显示在图形界面上层</li>
</ol>
<hr>
<p>好崩溃（划掉） </p>
<h2 id="1-有关字符集"><a href="#1-有关字符集" class="headerlink" title="1.有关字符集"></a>1.有关字符集</h2><p>据我了解，程序默认unicode字符集。“使用多字节字符集”和“使用Unicode字符集”的直接区别就是：编译器是否增加了宏定义——UNICODE。当选择“使用Unicode字符集”时，编译器会增加宏定义——UNICODE。而是否增加了宏定义UNICODE，则影响了一些Windows API的使用。例如：<br><code>MessageBox(NULL, L&quot;这是一个测试程序!&quot;, L&quot;Title&quot;, MB_OK);</code>这些api接受tchar类型的字符串，如果有unicode定义tchar就相当于LPCWSTR，否则tchar等同于char。所以如果使用Unicode，为了让api读懂char，我们使用_T””，或者L””转义。  </p>
<h2 id="2-链表文件读写"><a href="#2-链表文件读写" class="headerlink" title="2.链表文件读写"></a>2.链表文件读写</h2><p>主要是链表里的东西怎么进入文件，函数如下：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">saveStuInfo</span><span class="params">(link*lin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!lin-&gt;length)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;链表里没得东西\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;stu.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;打不开文件\n&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       node* a = lin-&gt;head;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%s %s %d\n&quot;</span>, a-&gt;name, a-&gt;passw, a-&gt;grade);</span><br><span class="line">           a = a-&gt;next;</span><br><span class="line">       &#125; <span class="keyword">while</span> (a != <span class="literal">NULL</span>); </span><br><span class="line">       <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-链表排序"><a href="#3-链表排序" class="headerlink" title="3.链表排序"></a>3.链表排序</h2><p>偷懒了，用的map，老师轻点扣分，毕竟这也说明我十分勤奋的学习了c++不是吗（）</p>
<h2 id="4-单击翻页"><a href="#4-单击翻页" class="headerlink" title="4.单击翻页"></a>4.单击翻页</h2><p>将图片一张张存到结构体，每次识别到鼠标左键按下打印下一张，可以使用batchdraw清屏打印</p>
<h2 id="5-messagebox显示"><a href="#5-messagebox显示" class="headerlink" title="5.messagebox显示"></a>5.messagebox显示</h2><p>一开始我发现我的提示box老被游戏界面挡住，也就是说显示在游戏下层，后来多方搜索我发现是这个参数<br><code>MessageBox(hnd, &quot;\t登录成功&quot;, &quot;提示&quot;, MB_OKCANCEL);</code>注意那个<strong>hnd</strong>！！<code>HWND hnd = GetHWnd();</code>一定要写窗口句柄，一开始我那里写的null，就被盖住了。。。。</p>
<hr>
<h1 id="以上都是简单问题，下面是真正难题"><a href="#以上都是简单问题，下面是真正难题" class="headerlink" title="以上都是简单问题，下面是真正难题"></a>以上都是简单问题，下面是真正难题</h1><ol start="7">
<li>马里奥如何判定碰到东西  </li>
<li>jSON文件如何实现到自己的程序上变成地图</li>
<li>如何让马里奥动起来</li>
<li>镜头跟随</li>
<li>除了主角外地图上其他东西怎么动起来（如金币）</li>
<li>最大的问题是<strong>怎么平衡写代码的时间和学课内知识的时间啊啊啊啊啊！</strong></li>
</ol>
<h2 id="1-马里奥碰撞判定"><a href="#1-马里奥碰撞判定" class="headerlink" title="1.马里奥碰撞判定"></a>1.马里奥碰撞判定</h2><p>一开始本来想着解析json文件，后来实在不会于是开了个巨大的二维数组记录地图信息，哪个格子有东西哪个没有，数字内容代表东西是什么。。。像这样<img src="/../someimage/wew.png"><br>然后就检测人的上下左右有没有撞到有东西的格子，这个判定我当时想了两天，晚上睡觉闭上眼睛也在想。。。</p>
<h2 id="2-json-gt-地图"><a href="#2-json-gt-地图" class="headerlink" title="2.json-&gt;地图"></a>2.json-&gt;地图</h2><p>说实话偷懒了，直接将做出来的地图导出成png了哈哈哈哈哈</p>
<h2 id="3-马里奥如何动起来"><a href="#3-马里奥如何动起来" class="headerlink" title="3.马里奥如何动起来"></a>3.马里奥如何动起来</h2><p>目前的办法是循环贴图贴背景，belike：  </p>
<pre><code>    while (1) &#123;
        putimage(mpx, 0, res.img_homeSubPage);//贴背景
        drawImg(x, y,108*n,0, 108,0,&amp;img);//贴人物，每次贴一个动态
        n++;
        if (n &gt;= 24)n = 0;//一共24个动态
        Sleep(20);
    &#125;
</code></pre>
<p>drawimg函数可以直接贴png格式图片，不用掩码图！！！！这个函数是同学网上找的，被我改了改，七个参数方便贴动态图。强烈推荐这个函数，贴出来的图比掩码图清晰，掩码图p不好的话贴出来有黑边（悲）    </p>
<pre><code>typedef struct _ARGB &#123;
byte a;
byte r;
byte g;
byte b;
&#125;ARGB;
ARGB color2Argb(DWORD c) &#123;
ARGB res;
res.r = (byte)c;
res.g = (byte)(c &gt;&gt; 8);
res.b = (byte)(c &gt;&gt; 16);
res.a = (byte)(c &gt;&gt; 24);
return res;
&#125;
DWORD argb2Color(ARGB c) &#123;
DWORD t = RGB(c.r, c.g, c.b);
return ((DWORD)c.a) &lt;&lt; 24 | t;
&#125;
void toGray(IMAGE* src) &#123;
DWORD* psrc = GetImageBuffer(src);
for (int i = 0; i &lt; src-&gt;getwidth() * src-&gt;getheight(); i++) &#123;
    ARGB t = color2Argb(psrc[i]);
    byte arv = (t.r + t.g + t.b) / 3;
    ARGB res = &#123; t.a,arv,arv,arv &#125;;
    psrc[i] = argb2Color(res);
&#125;
&#125;
</code></pre>
<p>前面都是结构体，下面是输出函数，到时候直接调用函数就好  </p>
<pre><code>void drawImg(int x, int y,int u,int m,int k,int d, IMAGE* src) &#123;
//从背景坐标x,y开始打印，打印图上u，m开始，宽k高d的部分
DWORD* pwin = GetImageBuffer();
DWORD* psrc = GetImageBuffer(src);
int win_w = getwidth();
int win_h = getheight();
int src_w = src-&gt;getwidth();

//int src_h = src-&gt;getheight();
int real_w = (k-u&gt; win_w) ? win_w - x : k;
int real_h = (d-m &gt; win_h) ? win_h - y : d;
if (x &lt; 0) &#123;
    psrc += -x; real_w -= -x; x = 0;
&#125;
if (y &lt; 0) &#123;
    psrc += (d * -y); real_h -= -y; y = 0;
&#125;
pwin += (win_w * y + x);
psrc += (src_w * m + u);
for (int iy = 0; iy &lt; real_h; iy++) &#123;
    for (int ix = 0; ix &lt; real_w; ix++) &#123;
        byte a = (byte)(psrc[ix] &gt;&gt; 24);
        if (a &gt; 100) &#123;
            pwin[ix] = psrc[ix];
        &#125;
    &#125;
    pwin += win_w;
    psrc += src_w;
&#125;
&#125;
</code></pre>
<p>实现效果：<img src="/../someimage/321.png"></p>
<h2 id="4-镜头跟随"><a href="#4-镜头跟随" class="headerlink" title="4.镜头跟随"></a>4.镜头跟随</h2><p>判定人物坐标，比如画面中央时500，500前不向后撤地图，500后人物不往前走，改为向后撤地图，map.x-&#x3D;step;</p>
<h2 id="5-金币动态"><a href="#5-金币动态" class="headerlink" title="5.金币动态"></a>5.金币动态</h2><p>方法时逐帧绘制，就是人动和金币动在一个计时循环里，金币四张图存成数组，用i控制播放哪张</p>
<h2 id="6-无解"><a href="#6-无解" class="headerlink" title="6.无解"></a>6.无解</h2>]]></content>
  </entry>
  <entry>
    <title>起岸希的第一篇博客</title>
    <url>/2023/03/21/first/</url>
    <content><![CDATA[<h2 id="好激动"><a href="#好激动" class="headerlink" title="好激动"></a>好激动</h2><p>对于一些计算机学习心得<br>起岸希觉得有必要分享一下  </p>
<span id="more"></span>
<p>首先记录一下<strong>markdown</strong>语法</p>
<blockquote>
<p>引用一下</p>
</blockquote>
<p>好了（空行退出引用段落）<br>插入代码段<br>空一行在打代码，每行前加一个tab</p>
<pre><code>int f[MAXN][21]; // 第二维的大小根据数据范围决定，不小于log(MAXN)
    for (int i = 1; i &lt;= n; ++i)
        f[i][0] = read(); // 读入数据
for (int i = 1; i &lt;= 20; ++i)
    for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j)
        f[j][i] = max(f[j][i - 1], f[j + (1 &lt;&lt; (i - 1))][i - 1]);
</code></pre>
<p>将单词变为代码<code>the fool</code>一个反引号包裹单词</p>
<hr>
<p>分割线<br>这是一个<a href="https://markdown.com.cn/basic-syntax/links.html">markdown语法链接</a><br>这是起岸希的email：<a href="mailto:&#x34;&#x33;&#x30;&#x33;&#x36;&#50;&#51;&#56;&#x35;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;">&#x34;&#x33;&#x30;&#x33;&#x36;&#50;&#51;&#56;&#x35;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;</a><br>这是图片 <img src="/../someimage/wdt.jpg" alt="picture">  </p>
]]></content>
  </entry>
  <entry>
    <title>工大杯比赛记录</title>
    <url>/2023/05/24/gdb/</url>
    <content><![CDATA[<h2 id="可能是因为大佬都没来，混了个好排名。。。"><a href="#可能是因为大佬都没来，混了个好排名。。。" class="headerlink" title="可能是因为大佬都没来，混了个好排名。。。"></a>可能是因为大佬都没来，混了个好排名。。。</h2><p><img src="/../someimage/5.jpg">  </p>
<span id="more"></span>  
<h2 id="比赛过程"><a href="#比赛过程" class="headerlink" title="比赛过程"></a>比赛过程</h2><p>需要感谢我自己的一点是比赛之前买了一杯一直想喝的奶茶，绿茶味的，很解困，加上是凉的，全程没怎么困过。。。这个比赛acm赛制让带资料，于是我带着我两本大书就去了，去了发现我不是阵仗最大的，一堆人拿着什么c primer什么c语言程序设计就来了，还有带物理作业的，我顿时就不紧张了。。。见到了久仰的大佬ysm，还是他来跟我打的招呼。。。比赛的时候真的很离谱，1:30了大家都开始写了我校园网还没上去2333，边上的大哥告诉我校园网网址才上去的。写了5题，一共8题，爽。  </p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>用时5min？<br>第一道题就让我很困惑。。。找数据就行，答案非常明显一眼就能看出，但是出题人小熊还是水了一页的字…找到答案后我都不敢置信。。一页的数据，那么多字，答案就这？但是看榜上大家都ac了一遍过，我心想也不能有什么坑，然后就交了,ac。至今我也不清楚他为什么给了那么多数据。  </p>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>用时30min<br>b题是另一个学长出的，有很多小坑点，擦边过的特判，任何时刻鸟都不能沾地啥的，写了老长，五六十行吧。第一次交没过，心态崩了往后写了，一个小时后我还是只过了A一道题，b和e都wa。返回来看的时候发现了一条补充说明。。。改改过了。</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>用时1h<br>这题我写的时候距离比赛结束还有一个小时，我当时排名30多，已经封榜了（这个真的坑，我一开始不知道封榜还寻思为什么做出的题变蓝了）就想着无所谓了爱对不对吧，我上学期11月蓝桥也是30多名，不就是毫无进步么，无所谓（悲）而且c题是我很久没练的树题！！当时看榜上比我强的基本就是C和F写了，然后C过的最多，我想着他最简单就开始尝试。写着写着我发现他不是二叉树，这就说明这应该不是道建树的题，每个给出father，所以我想着fa数组保存就不建树了，这样还挺简单的，最后证明我的想法是对的。。。<br>C题考的是最大未污染子树，我当时一看题以为要建树，而且这名字很耳熟，应该之前在学堂在线看过，但是没研究过，不过我当时其他的应该也不会了，于是我打算自创算法（）<br>就用fa保存整个树，re保存每个点红不红，ans保存每个点开始的子树数量。然后遍历每个点，如果这个点红就把他所有父亲标红，不红就把他自己和所有父亲的ans+1，直到红父亲或者根。最后遍历ans找最大的节点就是答案。我16的时候交了一次wa了，然后发现没看清题，找不到的时候要输出-1，然后又自己创造样例输入发现有个循环没进，这时候24了，各种调试发现原来是应该&lt;&#x3D;n写成&lt;n了，改完这些已经28了，我赶紧交了，剩下的就听天由命了，然后我看他那个评测一直转一直转我就害怕，然后！！居然过了！！我那一刻都快哭了，二叉树没白学，题没白做啊啊啊啊。。然后就29了，我躺尸等待考试结束。。。。好久没经历这么刺激的考试结束前7分钟了，真就创造奇迹，感觉把我排名拉高了十几名。。真就一念之间<img src="/../someimage/he.jpg"></p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>用时30min<br>小熊出的题，我当时想着一定要过，考哈希表嘛，我寻思看着很简单啊，遂交，wa。然后我觉得我的判断条件逻辑不好，遂改，又交，wa。然后自己想了几组数据测试，还真测出问题来了，判断的||写成&amp;&amp;了，你说怎么可能有数在&lt;1800的同时&gt;29597呢。改了，遂ac</p>
<h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>用时40min<br>这题是第4个过的，真的写爽了，快说，感谢ysm。。。各种STL啪啪往上招呼好快乐，一开始用的map后来发现不行，他（应该）没有按键key排完按value排的特性（按数字排序，同数字按名字排序），遂换priority_queue。发现也不行，他也不是先按pair的first排完按second。但是我有书啊！！我直接翻书哈哈哈哈哈，写了个cmp结构体给整出来了，<code>if(p1.first!=p2.first)return p1.first&lt;p2.first;   else return p1.second&gt;p2.second;</code>。不知道为什么两个符号是反的，反正结果是对的（狗头）我头一次体验到带书上阵的魅力。幸好没出bug，否则还真不会改。。。因为不了解实现。有句话说得好：</p>
<blockquote>
<p>我们至今仍未知道那题ac的原因  </p>
</blockquote>
<p>笑死。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经历过蓝桥杯和天梯赛的暴打可能人变踏实了一点。专心刷了几道不会的题，心态上也不那么狂了，轻易不尝试自己以前拿ide都调半天的题（这次的c是个例外哈哈哈，临时发挥出来了），devcpp越发熟练了，调试上没出大问题，比如“一顿操作猛如虎，运行一看没输出”这种，这次没有写出没输出的程序，也没有dfs啥的难调试的东西，就是基本理论想明白了实际就没什么别的问题。调程序很好的方法就是自己多创造几个样例，咱可以模拟那种很小的输入比如只有一两个点，一般就能看出问题了。<br>我要吐槽！学校破电脑黑窗口不能ctrl+v……每个测试例都要手动输入！！h题那个输入就逆天，电脑类型MacBook_Pro_19_2023，崩溃每次都来一遍，我都记下来了。。。</p>
]]></content>
  </entry>
  <entry>
    <title>蓝桥杯2022年题目思路</title>
    <url>/2023/03/29/lanqiao/</url>
    <content><![CDATA[<h2 id="E：爬树的甲壳虫"><a href="#E：爬树的甲壳虫" class="headerlink" title="E：爬树的甲壳虫"></a>E：爬树的甲壳虫</h2><p>状态转移方程：<img src="/../someimage/wsl.png">  </p>
<span id="more"></span>  

<p>其中i&#x3D;0,1…n。a[i]代表<strong>从a[i]开始爬到树顶的期望时间</strong>，即a[i-1]有p[i]的可能爬上a[i]并且继承a[i]的期望时间。有1-p[i]的可能掉到树根，从头来过，继承a[0]的时间。a[0]指从根开始爬到树顶的时间。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/11/17/modian/</url>
    <content><![CDATA[<h2 id="第四章-放大电路的频率响应"><a href="#第四章-放大电路的频率响应" class="headerlink" title="第四章 放大电路的频率响应"></a>第四章 放大电路的频率响应</h2><p> <img src="/../someimage/image-3.png" alt="Alt text"><br><img src="/../someimage/image-4.png" alt="Alt text"><br><img src="/../someimage/image-5.png" alt="Alt text"><br><img src="/../someimage/image-7.png" alt="Alt text"></p>
<ol>
<li>有源滤波电路<br><img src="/../someimage/image-6.png" alt="Alt text"><br><img src="/../someimage/image-8.png" alt="Alt text"><br><img src="/../someimage/image-9.png" alt="Alt text"><br><img src="/cfbc75c31a7f96c9bbda07f0b1d3750.jpg" alt="Alt text"><br><img src="/42c89ab1427b02ef10e4755c0922f40.jpg" alt="Alt text"></li>
<li>电容通高阻低<br>如果这个交流电的频率较低，正半周将电容器充满电荷以后，负半周仍未到来，则电流会在中途断流，则电容器对于这个低频的交流电来说，就不是完全通路了。</li>
</ol>
<h2 id="第五章-放大电路中的反馈"><a href="#第五章-放大电路中的反馈" class="headerlink" title="第五章 放大电路中的反馈"></a>第五章 放大电路中的反馈</h2><ol>
<li>正负反馈判断<br>判断三角右端：++ ——&gt;+ ； -+ ——&gt;-<br>引回到同向输入端为正<br>反向为负。多个运放时看整体<br><img src="/../someimage/sfsgs.png" alt="Alt text"><br>看三角里面的符号</li>
<li>直交流判断<br><img src="/../someimage/image-1.png" alt="Alt text"><br>看什么流能过。导线限制最小，电容只能过交流<br>与放大电路的耦合方式没关系, 只看反馈通路<br>第一个是直流反馈(交流的话, 电容将R1短路, 输出量引入GND,就没反馈了)<br>第二个是交流反馈(直流的话, 电容隔断电流,没反馈)<br>第三个是交 直流反馈</li>
<li>组态：电压&#x2F;电流，串联&#x2F;并连<br>同出为压，同入为并。<br><img src="/../someimage/image-2.png" alt="Alt text"></li>
<li>深度负反馈的放大倍数判断<br>先求组态，再套公式</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>关于ST表</title>
    <url>/2023/03/21/second/</url>
    <content><![CDATA[<h3 id="定义：用于求可重复性贡献问题的解。（即重复计算结果不变）对于一个一维数组，采用分治的方法，用一个二维数组储存每个区间内的最大最小值。f-a-b-表示从a开始2的b次方个数的最大值"><a href="#定义：用于求可重复性贡献问题的解。（即重复计算结果不变）对于一个一维数组，采用分治的方法，用一个二维数组储存每个区间内的最大最小值。f-a-b-表示从a开始2的b次方个数的最大值" class="headerlink" title="定义：用于求可重复性贡献问题的解。（即重复计算结果不变）对于一个一维数组，采用分治的方法，用一个二维数组储存每个区间内的最大最小值。f[a][b]表示从a开始2的b次方个数的最大值"></a>定义：用于求可重复性贡献问题的解。（即重复计算结果不变）对于一个一维数组，采用分治的方法，用一个二维数组储存每个区间内的最大最小值。<code>f[a][b]</code>表示从a开始2的b次方个数的最大值</h3><p>状态转移方程：f ( i , j ) &#x3D; m a x ( f ( i , j − 1 ) ,   f ( i + 2^(j − 1) , j − 1 ) )  </p>
<span id="more"></span>  

<p>将原区间分成两个大小相等子区间（因为长度是2的j次方，所以不存在不能等分的情况）<br>代码如下</p>
<pre><code>int f[MAXN][21]; // 第二维的大小根据数据范围决定，不小于log(MAXN)
    for (int i = 1; i &lt;= n; ++i)
           f[i][0] = read(); //读入数据
for (int j = 1; j &lt;= 20; ++j)//枚举倍数
    for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)//枚举起点,i到i+2^j-1刚好2^j个数
        f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j- 1))][j- 1]);
</code></pre>
<p>内部存储像这样 <img src="/../someimage/02.jpg" alt="picture"><br>对于询问(l,r)，寻找两个分别以l开头和以s结尾的区间，两区间的最大值即总最大值。我们需要使第一个子区间的右端点尽可能的接近r​，那么不妨直接令l + 2^s − 1 &#x3D; r即s&#x3D;lg[ r-l+1]向下取整。则区间[l,r]被分为：f[ l ][ l + 2^s - 1]和f[r-( 2^s -1)][ r ]  <strong>从l开始2^s个，从r往前2^s个</strong><br>对log进行预处理：<code>lg[i]=lg[i/2]+1;</code>,<code>lg[0]=-1;</code><strong>千万别忘！</strong>  </p>
]]></content>
  </entry>
  <entry>
    <title>关于ST表</title>
    <url>/2024/03/29/st/</url>
    <content><![CDATA[<h3 id="定义：用于求可重复性贡献问题的解。（即重复计算结果不变）对于一个一维数组，采用分治的方法，用一个二维数组储存每个区间内的最大最小值。f-a-b-表示从a开始2的b次方个数的最大值"><a href="#定义：用于求可重复性贡献问题的解。（即重复计算结果不变）对于一个一维数组，采用分治的方法，用一个二维数组储存每个区间内的最大最小值。f-a-b-表示从a开始2的b次方个数的最大值" class="headerlink" title="定义：用于求可重复性贡献问题的解。（即重复计算结果不变）对于一个一维数组，采用分治的方法，用一个二维数组储存每个区间内的最大最小值。f[a][b]表示从a开始2的b次方个数的最大值"></a>定义：用于求可重复性贡献问题的解。（即重复计算结果不变）对于一个一维数组，采用分治的方法，用一个二维数组储存每个区间内的最大最小值。<code>f[a][b]</code>表示从a开始2的b次方个数的最大值</h3><p>状态转移方程：f ( i , j ) &#x3D; m a x ( f ( i , j − 1 ) ,   f ( i + 2^(j − 1) , j − 1 ) )  </p>
<span id="more"></span>  

<p>将原区间分成两个大小相等子区间（因为长度是2的j次方，所以不存在不能等分的情况）<br>代码如下</p>
<pre><code>int f[MAXN][21]; // 第二维的大小根据数据范围决定，不小于log(MAXN)
    for (int i = 1; i &lt;= n; ++i)
           f[i][0] = read(); //读入数据
for (int j = 1; j &lt;= 20; ++j)//枚举倍数
    for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)//枚举起点,i到i+2^j-1刚好2^j个数
        f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j- 1))][j- 1]);
</code></pre>
<p>内部存储像这样 <img src="/../someimage/02.jpg" alt="picture"><br>对于询问(l,r)，寻找两个分别以l开头和以s结尾的区间，两区间的最大值即总最大值。我们需要使第一个子区间的右端点尽可能的接近r​，那么不妨直接令l + 2^s − 1 &#x3D; r即s&#x3D;lg[ r-l+1]向下取整。则区间[l,r]被分为：f[ l ][ l + 2^s - 1]和f[r-( 2^s -1)][ r ]  <strong>从l开始2^s个，从r往前2^s个</strong><br>对log进行预处理：<code>lg[i]=lg[i/2]+1;</code>,<code>lg[0]=-1;</code><strong>千万别忘！</strong>  </p>
]]></content>
  </entry>
  <entry>
    <title>数字逻辑知识点总结</title>
    <url>/2024/03/29/shuluo/</url>
    <content><![CDATA[<p>希希很讨厌这门课orz，很玄妙  </p>
<ol>
<li>根据真值表画卡诺图   <span id="more"></span></li>
</ol>
<p>真值表里是1，对应卡诺图也就填1.比如011(3)是1，那么卡诺图里的011也就是1.真值表里是0同理。 真值表里变量顺序无所谓<br><img src="/../someimage/knt.png"><br><strong>AB为最高位！！</strong>  </p>
<ol>
<li>根据最小项画卡诺图<br>最小项m（1，3，4），对应的位置表格里填1，最大项反之   </li>
<li>卡诺图直接化简出与或式</li>
<li>门级结构描述f&#x3D;x2~x3+x1x3   <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line"><span class="keyword">input</span> x3,</span><br><span class="line"><span class="keyword">input</span> x2,</span><br><span class="line"><span class="keyword">input</span> x1,</span><br><span class="line"><span class="keyword">output</span> f</span><br><span class="line">);</span><br><span class="line"><span class="keyword">wire</span> w1,w2;<span class="comment">//连出的线</span></span><br><span class="line"><span class="keyword">and</span> a1(w1,x2,~x3),a2(w2,x3,x1);</span><br><span class="line"><span class="keyword">or</span> o1(f,w1,w2);</span><br><span class="line"><span class="keyword">endmodule</span>;</span><br></pre></td></tr></table></figure></li>
<li>数据流描述（不关心门的构造，只管描述表达式）   <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tm(</span><br><span class="line"><span class="keyword">input</span> x1,</span><br><span class="line"><span class="keyword">input</span> x2,</span><br><span class="line"><span class="keyword">input</span> x3,</span><br><span class="line"><span class="keyword">output</span> f</span><br><span class="line">);</span><br><span class="line"><span class="keyword">assign</span> f=(~x3&amp;x2)|(x3&amp;x1);<span class="comment">//一定有assign，是重点,好像括号没有太大的必要</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
<li>行为描述（模块）<br>用到always之类的块</li>
<li>2421码<br>从左到右，第一位权值为2，第二位的权值为4，第三位的权值为2，第四位的权值为1。 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> zh8421_2421(in,out,err);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>]in;<span class="comment">//4位，不写则为一位</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>]out;</span><br><span class="line">    <span class="keyword">output</span> err;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]out;<span class="comment">//reg表示被定义的信号将用在always模块内</span></span><br><span class="line">    <span class="keyword">reg</span> err;<span class="comment">//四个口也可以写在上面括号里</span></span><br><span class="line">        <span class="keyword">always</span>@(in)</span><br><span class="line">            <span class="keyword">if</span>(in&gt;<span class="number">4&#x27;b1001</span>)<span class="comment">//&gt;9,&#x27;b表示二进制，&#x27;h十六进制</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                out=<span class="number">0</span>;</span><br><span class="line">                err=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(in&gt;<span class="number">4&#x27;b0100</span>)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                out=in+<span class="number">4&#x27;b0110</span>;</span><br><span class="line">                err=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                out=in;</span><br><span class="line">                err=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
<li>一些运算符<br>&amp;按位与<br>&amp;&amp;逻辑与<br>位拼接{}<br>b[3]b为4位向量的<strong>第一位</strong>，最左边这个-&gt;口口口口,还有b[2],b[1]……注意和数组是反的  </li>
<li>一些奇怪的名词  <ol>
<li>半加器 指对输入的两个一位二进制数相加（A与B），输出<strong>一个结果位（SUM）和进位（C）</strong>，没有进位的输入加法器电路，是一个实现一位二进制数的加法电路  </li>
<li>全加器 输入两个二进制位和一个进位，一起运算后输出和和进位<br> <img src="/..%5Csomeimage%5Cssk.png"></li>
<li>全减器<br> <img src="/image-18.png" alt="Alt text"><br> bo的a取非，其他一样。接受来自低位的借位，输出向高位的借位。</li>
</ol>
</li>
<li>一些逻辑式化简规则<br><img src="/..%5Csomeimage%5C707.jpg"></li>
<li>逻辑险象<br>也称逻辑冒险。 两个输入信号同时向相反方向的逻辑电平跳变的现象（即一个由1- &gt; 0， 另一个从0 -&gt; 1），称为竞争。<br>因竞争导致在输出端可能产生尖峰脉冲的现象，称为冒险。<img src="/..%5Csomeimage%5C81ca.png"><br>判断逻辑险象：出现相切的卡诺图，或式中A和A’同时出现。<img src="/..%5Csomeimage%5C732.png"><img src="/..%5Csomeimage%5C142.png"><br>ps消除时也画包含切线的最大圈！</li>
<li>典型代码类型<br>格雷码：二进制转格雷码要用三个异或</li>
<li>触发器<br>很抽象。<br>同步置位:上升沿来临才赋值<br>异步：异步置位与复位是与时钟无关的。把它们列入always块的事件控制括号内就能触发always块的执行。<br><img src="/image.png" alt="Alt text"><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//边沿JK触发器。同步</span></span><br><span class="line"><span class="keyword">module</span> jk_trigger(clk, j, k, q);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">input</span> clk, j, k;</span><br><span class="line"><span class="keyword">output</span> q;</span><br><span class="line"><span class="keyword">reg</span> q;</span><br><span class="line"><span class="keyword">wire</span> qb;</span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)       <span class="comment">//时钟上升沿到来时，判断jk的值</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">case</span>(&#123;j,k&#125;)</span><br><span class="line">	<span class="number">2&#x27;b00</span>: q &lt;= q;       <span class="comment">//如果&#123;j,k&#125;=00，则触发器处于保持状态</span></span><br><span class="line">	<span class="number">2&#x27;b01</span>: q &lt;= <span class="number">1&#x27;b0</span>;    <span class="comment">//如果&#123;j,k&#125;=01，则触发器置1</span></span><br><span class="line">	<span class="number">2&#x27;b10</span>: q &lt;= <span class="number">1&#x27;b1</span>;    <span class="comment">//同理10，清零</span></span><br><span class="line">	<span class="number">2&#x27;b11</span>: q &lt;= ~q;      <span class="comment">//11,翻转</span></span><br><span class="line">	<span class="keyword">default</span>: q &lt;= q;</span><br><span class="line">	<span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">assign</span> qb = ~q;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
D画波形的题：锁存器在有效时与输入D保持一致。触发器在有效边沿来临时与来临前的D值保持一致。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>These dependencies were not found:* @/config/config</title>
    <url>/2024/03/29/these%20dependencies%20were%20not%20found/</url>
    <content><![CDATA[<h2 id="webstorm导入项目发生报错"><a href="#webstorm导入项目发生报错" class="headerlink" title="webstorm导入项目发生报错"></a>webstorm导入项目发生报错</h2><h3 id="完整报错："><a href="#完整报错：" class="headerlink" title="完整报错："></a>完整报错：</h3><p><code>* @/config/config in ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./  node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/TestCase.vue?vue&amp;type=script&amp;lang=js&amp;, ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Editor/MarkdownEditor.vue?vue&amp;type=script&amp;lang=js&amp; and 6 others</code>  </p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>这个报错说明我src&#x2F;config&#x2F;路径下缺少config.js文件。增加以后报错减少到了一行。</li>
<li>vue.config.js文件里边lintOnSave字段值改为false<br><img src="/../someimage/image-25.png" alt="Alt text"></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>pta天梯赛补题——蒟蒻不愿再拖后腿</title>
    <url>/2023/04/19/tianti/</url>
    <content><![CDATA[<h2 id="L1-017到底有多二"><a href="#L1-017到底有多二" class="headerlink" title="L1-017到底有多二"></a>L1-017到底有多二</h2><p>ac code:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a;</span><br><span class="line"><span class="type">int</span> k,q=<span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> n,e=<span class="number">1</span>,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]==<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> d=a.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!(a[a.<span class="built_in">size</span>()<span class="number">-1</span>]&amp;<span class="number">1</span>))q=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>)&#123;e=<span class="number">1.5</span>;d--;&#125;</span><br><span class="line">    n=(<span class="type">double</span>)k/d;</span><br><span class="line">    ans=n*(<span class="type">double</span>)q*e*<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf%%&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>我一开始数字长度d是用<code>int d=(a[0]==&#39;-&#39;?(a.size()-1):(a.size()-2));</code>写的，但是测试点2，4过不去。。。改成特判就好了，想了一下，因为长度就是位数。。不需要再减。应该是不减和减一，后者误打误撞对了。所以测试点2，4应该是正数~~~其他的都是负数</p>
<h2 id="L1-095分寝室"><a href="#L1-095分寝室" class="headerlink" title="L1-095分寝室"></a>L1-095分寝室</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line">   <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">   set&lt;<span class="type">int</span>&gt;v, v1;</span><br><span class="line">   <span class="type">int</span> a, b, c, ans1, ans2, k,d=INF;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">getc</span><span class="params">(set&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           v.<span class="built_in">insert</span>(i);</span><br><span class="line">           v.<span class="built_in">insert</span>(n / i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> it1 = v1.<span class="built_in">begin</span>(); it1 != v1.<span class="built_in">end</span>(); it1++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (*it + *it1 == a)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="type">int</span> temp = b / (*it), temp1 = c / (*it1);</span><br><span class="line">               <span class="keyword">if</span> (<span class="built_in">abs</span>(temp - temp1 )&lt; d) &#123;</span><br><span class="line">                   ans1 = *it; ans2 = *it1;</span><br><span class="line">                   d =<span class="built_in">abs</span>( temp - temp1);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin&gt;&gt;b&gt;&gt;c&gt;&gt;a;</span><br><span class="line">   <span class="built_in">getc</span>(v,b);</span><br><span class="line">   <span class="built_in">getc</span>(v1,c);</span><br><span class="line">   <span class="built_in">solve</span>();</span><br><span class="line">   <span class="keyword">if</span> (d != INF)</span><br><span class="line">       cout &lt;&lt; ans1&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; ans2;</span><br><span class="line">   <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这破题我在考场上只得了2分，一共20分，没错，就是输出no solution这两分……我很崩溃说实话，但是我把方法想复杂了，人家大佬十几行解决问题，而我40多行今天由调了半个多小时才ac。<br>之前错在  </p>
<ol>
<li>自己不是很清楚每步求的啥……我set里放的是可能的寝室数而不是一个寝室可能的人数……  </li>
<li>c打成b了,关键是样例还过了，我自己测了几个样例也没问题，就离谱</li>
</ol>
<p>说一下和大佬思路的差距，我想着求出所有因子，for循环嵌套找加起来等于n的再细算。大佬从1枚举到n，只要一层循环枚举两边寝室数然后判断能不能被总人数整除。从时间复杂度和行数上讲，我的思路都弱爆了  </p>
<h2 id="L2-045堆宝塔"><a href="#L2-045堆宝塔" class="headerlink" title="L2-045堆宝塔"></a>L2-045堆宝塔</h2><p>ac code:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, s[<span class="number">2000</span>], cou = <span class="number">0</span>, maxx;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;a, b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clear</span><span class="params">(stack&lt;<span class="type">int</span>&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">   &#123;</span><br><span class="line">       s.<span class="built_in">pop</span>();</span><br><span class="line">       i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swi</span><span class="params">(stack&lt;<span class="type">int</span>&gt;&amp; s, <span class="type">int</span> aa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &gt; aa)</span><br><span class="line">   &#123;</span><br><span class="line">       a.<span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">       s.<span class="built_in">pop</span>();</span><br><span class="line">       i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cin &gt;&gt; s[i];</span><br><span class="line">   &#125;</span><br><span class="line">   a.<span class="built_in">push</span>(s[<span class="number">0</span>]);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (a.<span class="built_in">empty</span>() || s[i] &lt; a.<span class="built_in">top</span>())</span><br><span class="line">           a.<span class="built_in">push</span>(s[i]);</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (b.<span class="built_in">empty</span>() || s[i] &gt; b.<span class="built_in">top</span>())</span><br><span class="line">           b.<span class="built_in">push</span>(s[i]);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//int r = a.top();</span></span><br><span class="line">           <span class="type">int</span> ck = <span class="built_in">clear</span>(a);</span><br><span class="line">           <span class="built_in">swi</span>(b, s[i]);</span><br><span class="line">           a.<span class="built_in">push</span>(s[i]);</span><br><span class="line">           maxx = <span class="built_in">max</span>(maxx, ck);</span><br><span class="line">           cou++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!a.<span class="built_in">empty</span>()) &#123; cou++; maxx = <span class="built_in">max</span>(maxx, (<span class="type">int</span>)a.<span class="built_in">size</span>()); &#125;<span class="comment">//很重要</span></span><br><span class="line">   <span class="keyword">if</span> (!b.<span class="built_in">empty</span>()) &#123; cou++; maxx = <span class="built_in">max</span>(maxx, (<span class="type">int</span>)a.<span class="built_in">size</span>()); &#125;</span><br><span class="line">   cout &lt;&lt; cou &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个我还真没看见啥简单方法，入栈出栈很难调，赛场上崩溃了也只拿了15分，一共25分。就是看清题意，用top前先判空。</p>
<h2 id="L2-046天梯赛的赛场安排"><a href="#L2-046天梯赛的赛场安排" class="headerlink" title="L2-046天梯赛的赛场安排"></a>L2-046天梯赛的赛场安排</h2><p>24分code:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, c, temp, v;</span><br><span class="line">string u;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vv;</span><br><span class="line">vector&lt;string&gt;ss;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, string&gt;&gt;q;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vv.<span class="built_in">size</span>(); i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (vv[i] + a &lt;= c)</span><br><span class="line">       &#123;</span><br><span class="line">           vv[i] += a;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">   temp = n;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">       q.<span class="built_in">push</span>(&#123; v,u &#125;);</span><br><span class="line">       ss.<span class="built_in">push_back</span>(u);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">       v = q.<span class="built_in">top</span>().first;</span><br><span class="line">       u = q.<span class="built_in">top</span>().second;</span><br><span class="line">       q.<span class="built_in">pop</span>();</span><br><span class="line">       <span class="keyword">if</span> (v &gt;= c) &#123; </span><br><span class="line">           vv.<span class="built_in">push_back</span>(c);</span><br><span class="line">           v -= c;</span><br><span class="line">           q.<span class="built_in">push</span>(&#123; v,u &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="built_in">find</span>(v))</span><br><span class="line">               vv.<span class="built_in">push_back</span>(v);</span><br><span class="line">       &#125;</span><br><span class="line">       num++;</span><br><span class="line">       mp[u] += num;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp.<span class="built_in">size</span>(); i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; ss[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mp[ss[i]] &lt;&lt; endl;;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; vv.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主打一个ac但没有完全ac，有一个点T了，别问，问就是没想到简单方法，大佬说直接那人数除c取余再入队就好了，我搁这搁这呢。想一想确实啊，大于c的时候队列顺序不影响赛场数，直到最大的小于c的数入队，然后第二大……就当熟悉stl了，今天学到的冷知识：unordered_map居然是随机的，完全无序。pair取出后用.访问元素，优先队列先按first排序再按second  </p>
<h2 id="L2-048寻宝图"><a href="#L2-048寻宝图" class="headerlink" title="L2-048寻宝图"></a>L2-048寻宝图</h2><p>这题在考场上写了一个小时，2分好像，妈的破防了。devcpp那个傻逼调试我调了半天才发现我把字符串当int存了，但是只会硬拆。。。直到自己补题的时候还在用数组mp[][]存图，上网查之后才知道string[]存图和二维数组性能一样。。。。<br>ac code:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, ch[<span class="number">5</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;, ch1[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> num, ans, f;</span><br><span class="line">string mp[<span class="number">100005</span>];<span class="comment">//如果int[][]会数组过大，以后记得1e5以上的就别开二维了。。。</span></span><br><span class="line">string a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (mp[a][b] &gt; <span class="string">&#x27;1&#x27;</span> &amp;&amp; mp[a][b] &lt;= <span class="string">&#x27;9&#x27;</span>)f = <span class="number">1</span>;</span><br><span class="line">   mp[a][b] = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//开不了vis数组干脆踩到置0</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> k = a + ch[i], s = b + ch1[i];</span><br><span class="line">       <span class="keyword">if</span>(k&gt;=<span class="number">0</span>&amp;&amp;k&lt;n&amp;&amp;s&gt;=<span class="number">0</span>&amp;&amp;s&lt;m&amp;&amp;mp[k][s]&gt;<span class="string">&#x27;0&#x27;</span>)<span class="comment">//最偏离我思考的，不需要的别踩。。。</span></span><br><span class="line">           <span class="built_in">dfs</span>(k, s);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cin &gt;&gt; mp[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (mp[i][j]!=<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">               <span class="built_in">dfs</span>(i, j);</span><br><span class="line">               <span class="keyword">if</span> (f)num++;</span><br><span class="line">               ans++;</span><br><span class="line">               f = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我现在都不知道为什么这一版过了而二维数组版没过。。按理来说样例很小两种方法应该没区别。可能是因为我自己写的那版的思路是：</p>
<ol>
<li>边界：踩到0返回</li>
<li>四种偏移只要不超界都踩一遍</li>
<li>用vis数组保存踩过的非0，main函数判断没踩过的非零开始dfs。后来让vis保存踩过的所有也不行，不会了。。。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2023/04/03/xianduanshu/</url>
    <content><![CDATA[<h2 id="节点：线段树节点每个代表一个区间，用二分法将每个区间依次减半直到最小，故节点数量是元素数量的二倍。节点内包含三个部分："><a href="#节点：线段树节点每个代表一个区间，用二分法将每个区间依次减半直到最小，故节点数量是元素数量的二倍。节点内包含三个部分：" class="headerlink" title="节点：线段树节点每个代表一个区间，用二分法将每个区间依次减半直到最小，故节点数量是元素数量的二倍。节点内包含三个部分："></a>节点：线段树节点每个代表一个区间，用二分法将每个区间依次减半直到最小，故节点数量是元素数量的二倍。节点内包含三个部分：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, mx;<span class="comment">//mx为每个区间内要维护的数值（通常为最大，最小值）</span></span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<span id="more"></span>  

<h2 id="建树："><a href="#建树：" class="headerlink" title="建树："></a>建树：</h2><pre><code>void build(int u, int l, int r) &#123;//初始化 u:节点编号 从根节点（编号最小的）向下递归
if (l == r)tr[u] = &#123; l,r,0 &#125;;
else &#123;
    tr[u] = &#123; l,r,0 &#125;;
    int mid = l + r &gt;&gt; 1;
    build(u*2, l, mid), build(u*2+1, mid + 1, r);
    &#125;
&#125;
</code></pre>
<h2 id="维护："><a href="#维护：" class="headerlink" title="维护："></a>维护：</h2><pre><code>inline void pushup(int u) &#123;
tr[u].mx = max(tr[ul].mx, tr[ur].mx);//维护max
&#125;
</code></pre>
<h2 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h2><pre><code>void modify(int u, int d, int f) &#123;//当前节点编号 要修改的节点编号 改成什么
if (tr[u].l == d &amp;&amp; tr[u].r == d) &#123;
    tr[u].mx = f;
&#125;
else &#123;
    int mid = (tr[u].l + tr[u].r) &gt;&gt; 1;
    if (mid &gt;= d)modify(u*2, d, f);
    if (mid &lt; d)modify(u*2+1, d, f);
    pushup(u);
&#125;
&#125;
</code></pre>
<h2 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h2><pre><code>int query(int u, int l, int r) &#123;
if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;
    return tr[u].mx;
&#125;
else &#123;
    int mid = tr[u].l + tr[u].r &gt;&gt; 1;
    int t = 0;
    if (mid &gt;= l)t = query(u*2, l, r);
    if (mid &lt; r)t = max(t, query(u*2+1, l, r));
    return t;
&#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>前端开发报错处理方法集中</title>
    <url>/2024/03/30/%E5%89%8D%E7%AB%AF%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h3 id="Vue-warn-Error-in-v-on-handler-Promise-x2F-async-“TypeError-this-fetch-is-not-a-function”"><a href="#Vue-warn-Error-in-v-on-handler-Promise-x2F-async-“TypeError-this-fetch-is-not-a-function”" class="headerlink" title="[Vue warn]: Error in v-on handler (Promise&#x2F;async): “TypeError: this.fetch is not a function”"></a>[Vue warn]: Error in v-on handler (Promise&#x2F;async): “TypeError: this.fetch is not a function”</h3><p>这是我在引用vue_json_excel包时报的错。解决方法：</p>
<pre><code>    fetch () &#123;
        return () =&gt; &#123;&#125;
    &#125;
</code></pre>
<p>不过改完之后还是下载不了转为excel表格的数据。后来发现我data（）的位置搁错了，我又建了一个data1函数，应该就搁在data里<br><img src="/../someimage/image-26.png" alt="Alt text"></p>
]]></content>
  </entry>
  <entry>
    <title>电脑下侧任务栏不显示</title>
    <url>/2023/10/09/%E4%B8%8B%E8%BE%B9%E6%A0%8F/</url>
    <content><![CDATA[<ol>
<li>ctrl+shift+ESC打开任务管理器  </li>
<li>找到左侧的“资源管理器”。如果没有点击一下桌面的此电脑就有了  </li>
<li>右键选择“重新启动”  </li>
<li>下边栏就回来了！！</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>图论算法总结</title>
    <url>/2023/12/06/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>总是看博客，总是记不住，我服了，稀巴烂</p>
<hr>
<p>###1. floyd<br>1.介绍<br>　　floyd算法只有五行代码，代码简单，三个for循环就可以解决问题，所以它的时间复杂度为O(n^3)，常用于：<br>求取图中任意两点之间的关系；<br>多元最短路，任意两点之间的距离关系；<br>图上的传递闭包任意两点之间的连通关系   </p>
<span id="more"></span>  
<p>2.思想：<br>　　Floyd算法的基本思想如下：从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点X到B。所以，我们假设Dis(AB)为节点A到节点B的最短路径的距离，对于每一个节点X，我们检查Dis(AX) + Dis(XB) &lt; Dis(AB)是否成立，如果成立，证明从A到X再到B的路径比A直接到B的路径短，我们便设置Dis(AB) &#x3D; Dis(AX) + Dis(XB)，这样一来，当我们遍历完所有节点X，Dis(AB)中记录的便是A到B的最短路径的距离。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;=n; k++)</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">                <span class="keyword">if</span>(map[i][j]&gt;map[i][k]+map[k][j] )<span class="comment">//距离</span></span><br><span class="line">                    map[i][j]=map[i][k]+map[k][j];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>floyd求两点之间是否有通路（正常解法也行，可简化为这个，传递闭包思想）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;x , &amp;y);</span><br><span class="line">    f[x][y] = <span class="number">1</span>;<span class="comment">//建的是有向图。后面判断要用f[i][j]|f[j][i]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k ++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)</span><br><span class="line">            f[i][j] |= (f[i][k] &amp; f[k][j]);<span class="comment">//重点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于每个点，只要这个点和其他n-1个点的关系都确定了，就能确定他在拓扑排序中的唯一排名。</p>
]]></content>
  </entry>
  <entry>
    <title>批处理</title>
    <url>/2023/11/19/%E6%89%B9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>批处理：利用系统内部命令<br>命令行创建：<br><img src="/../someimage/image-15.png" alt="Alt text"></p>
<h3 id="一些命令行操作"><a href="#一些命令行操作" class="headerlink" title="一些命令行操作"></a>一些命令行操作</h3><p>创建文件 echo .&gt;a.txt<br>查看文件 type a.txt</p>
<span id="more"></span>  
<p>清屏 cls<br>目录 dir<br>set &#x2F;a 1+2 执行算术运算<br><img src="/../someimage/image-17.png" alt="Alt text"><br>记事本创建:<br>将记事本后缀改为bat,双击运行</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol>
<li>基本语法<br><img src="/../someimage/image-16.png" alt="Alt text"><br>第一句关闭盘符输出<br>重定向：<br>echo hello world &gt;a.txt(定向到a，如没有则新建)<br>重定向符号 &gt;(覆盖) &gt;&gt;(追加) &lt; &lt;&lt;</li>
<li>执行算术运算<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set /a var=1+2;</span><br><span class="line">echo %var%  //代表var是一个变量</span><br></pre></td></tr></table></figure></li>
<li>运算符<br>&amp;&amp; || |（管道运算符，链接命令和子命令dir | find “.txt”）</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>网安导论复习</title>
    <url>/2023/12/18/%E7%BD%91%E5%AE%89%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<p>第1章绪论</p>
<ol>
<li>什么是网络空间？网络空间安全的核心内涵是什么？<br>–人们赖以生存的信息环境，是所有信息系统的集合。<br>–信息安全。</li>
<li>信息的安全属性。<br>–可用性（availability）、可控性 (controllability)、完整性 (integrity)、保密性 (confidentiality)、不可否认性 (non-repudiation)。</li>
<li>信息安全概念演变的三个阶段。<br>–通信安全-&gt;计算机安全和信息系统安全-&gt;信息安全保障</li>
<li>如何理解《信息保障技术框架》中的PDRR模型。<br>–整个信息和信息系统的保护和防御：保护，检测，相应和恢复能力</li>
<li>什么是信息安全保障？信息安全保障的三要素是什么？<br>–保护和防御信息及信息系统，确保其可用性，完整性，保密性，可控性，不可否认性等等。这包括在信息系统中融入保护，检测，相应功能，并提供信息系统恢复功能。<br>–人，技术，管理</li>
<li>我国27号文的总体要求。<br>–我国信息安全保障工作的总体要求是，坚持积极防御，综合防范的方针，全面提高信息安全防护能力，重点保障<strong>基础信息网络</strong>和<strong>重要信息系统</strong>的安全。</li>
<li>脆弱性及信息系统的脆弱性主要体现在哪些方面？<br>–硬件设施的脆弱性，软件的脆弱性，网络通信协议的脆弱性，管理的脆弱性。</li>
<li>什么是威胁？威胁的分类。<br>–是指导致“信息系统受到损害”这种不期望事件发生的潜在原因。</li>
<li>什么是攻击？理解《信息保障技术框架》定义的5类攻击。<br>–导致“信息系统受到损害”的行为<br>–主动，被动，临近，内部人员，分发</li>
<li>什么是信息安全风险？衡量风险的指标有多少？<br>–指由于信息系统存在的脆弱性，人为或者自然的威胁导致<strong>信息安全事件（攻击）发生的可能性</strong>及其<strong>造成的影响</strong>。<br>–两个指标</li>
</ol>
<p>第2章 计算系统、网络系统和信息系统</p>
<ol>
<li>冯·诺依曼原理（硬件的组成部件，指令和数据的表示等）<br>–硬件由运算器，控制器，存储器，输入设备和输出设备构成<br>–指令和数据用二进制表示</li>
<li>理解网络系统的构成。<br>–网络边缘：连在网络上的各类主机和host<br>–网络核心：分组交换设备和通信链路构成的网状网络。</li>
<li>什么是网络协议？其三要素是什么？<br>–为进行网络中的数据交换而建立的规则，标准或约定。通信双方需要共同遵守，互相理解。<br>–规定传输数据的<strong>格式</strong>（如何讲）<br>–规定所要完成的<strong>功能</strong><br>–规定各种操作的<strong>顺序</strong></li>
<li>OSI和TCP&#x2F;IP参考模型的层次结构图各是什么？了解各层的主要功能。<br>–<img src="/image-23.png" alt="Alt text"><br><img src="/image-24.png" alt="Alt text"></li>
</ol>
<p>第3章 密码学基础</p>
<ol>
<li>什么是密码技术？<br>–将正常的，可识别的信息转变成无法识别的信息。</li>
<li>密码学的分类。<br>–密码编码学，密码分析学</li>
<li>掌握密码学的基本概念<br>–明文，密文……</li>
<li>从双方加密通信的过程理解密码学的目的。</li>
<li>了解密码学发展各个阶段（古典密码、近代密码和现代密码）的基本特点、核心手段和标志性事件。<br>–古典密码学：代换，置换<br>–近代密码：数据安全开始基于密钥<br>–现代密码：对称，不对称密钥，RSA</li>
<li>了解密码体制的不同分类；<br>–对称密码体制，非对称，混合<br>–分组密码，流密码</li>
<li>理解常见的密码破译攻击。了解常见的密码分析方法。<br>–唯密文攻击，已知明文攻击，选择明文攻击，选择密文攻击。<br>–分析方法：穷举攻击，统计分析攻击，解密变换攻击</li>
<li>理解密码体制的安全性，掌握实用密码体制需要满足的基本条件和<strong>准则</strong>。<br>–破译的代价超出信息本身的价值<br>–破译的实践超出信息的有效期</li>
<li>理解公钥加密和私钥签名。<br>–前者用公钥加密私钥解密，后者繁殖</li>
</ol>
<h2 id="第4章-系统安全基础1-理解网络空间的系统安全所包含的两层含义。2-了解基于安全芯片（如TPM）的可信计算思想。–以硬件安全保证计算机安全3-了解访问控制技术，知道访问控制实施框架的原型，理解访问矩阵"><a href="#第4章-系统安全基础1-理解网络空间的系统安全所包含的两层含义。2-了解基于安全芯片（如TPM）的可信计算思想。–以硬件安全保证计算机安全3-了解访问控制技术，知道访问控制实施框架的原型，理解访问矩阵" class="headerlink" title="第4章 系统安全基础1. 理解网络空间的系统安全所包含的两层含义。2. 了解基于安全芯片（如TPM）的可信计算思想。–以硬件安全保证计算机安全3. 了解访问控制技术，知道访问控制实施框架的原型，理解访问矩阵"></a>第4章 系统安全基础<br>1. 理解网络空间的系统安全所包含的两层含义。<br>2. 了解基于安全芯片（如TPM）的可信计算思想。<br>–以硬件安全保证计算机安全<br>3. 了解访问控制技术，知道访问控制实施框架的原型，理解访问矩阵</h2><ol start="4">
<li>身份认证与访问控制技术的区别和联系<br>–鉴别用户身份，后者控制对一个信息系统及其资源的所有访问。只允许经过授权的访问。</li>
<li>什么是安全审计？<br>–对用户使用何种信息资源，使用的时间，以及如何使用进行记录与监控。</li>
<li>了解操作系统安全技术对确保数据库系统安全的作用<br>–前者保护了后者</li>
<li>知道数据库系统的关键安全技术由谁提供，理解并发控制技术的产生动机和经典基于封锁并发控制技术的基本原理。<br>–操作系统？<br>–多个用户同时使用<br>–事务T在对某个数据对象操作之前，先向系统申请对其加锁</li>
<li>了解恶意代码的常见危害；了解代码分析技术的分类。<br>–攻击系统，肆意占用资源，危害数据文件，泄露，攻击应用程序。<br>–静态分析（看），动态分析（干）</li>
<li>了解主机漏洞扫描技术的基本原理。<br>–在本地运行检测系统漏洞的程序</li>
<li>理解常见的备份策略和恢复策略。<br>–全备份，增量备份，差分备份。全部恢复，个别文件恢复，重定向文件恢复。</li>
</ol>
<p>第5章 网络安全基础</p>
<ol>
<li>了解OSI(开放系统互连)安全体系结构定义的5种安全服务。<br>–鉴别，访问控制，数据保密，数据完整性，抗抵赖服务</li>
<li>了解OSI安全体系结构定义的8种安全机制。<br>–<em>加密，数字签名</em>，访问控制，数据完整性，鉴别交换，<em>通信业务填充，路由选择控制，公证</em></li>
<li>理解防火墙的作用和功能，了解防火墙的分类，理解三类防火墙技术（包过滤、状态检测和代理服务）的基本原理。<br>–作用：边界保护，功能：访问控制，内容控制，日志功能，自身安全和可用性。</li>
<li>了解为什么要有入侵检测技术？了解常见的入侵检测技术，了解入侵检测系统的关键性能参数 。<br>–弥补其他安全产品或措施的缺陷<br>–异常检测技术（正常行为描述库），误用检测技术（异常……）<br>–误报，漏报</li>
<li>什么是VPN，VPN的优点和常见分类。<br>–在公用网络上，按照与专用网络相同的安全策略和管理规则建立的私有网络连接<br>–费用低，隧道的拓扑结构<br>–远程访问的vpn（个人-公司），站点到站点的（公司分支-公司）</li>
<li>了解IPsec的组成，了解AH、ESP的协议数据单元，理解IPsec建立SA的目的。<br>–两个安全协议：AH认证头协议，ESP封装安全载荷协。SA定义了通信双方<strong>保护一定数据流量的策略</strong><br>–一个密钥管理协议IKE</li>
<li>了解网络安全等级保护制度的作用对象和定级要素。理解网络安全等级保护的工作机制和步骤。<br>–包括基础网络设施，信息系统，以及数字资源等<br>–公民，法人和其他组织的合法权益。社会秩序和公共利益。国家安全。<br>–定级-&gt;备案-&gt;建设整改-&gt;等级测评-&gt;监督检查（都要）</li>
<li>了解一种新兴网络的基本概念和安全技术需求。<br>–物联网，感知层（攻击硬件），应用层（隐私保护），网络层，平台层。<br>–工业互联网，网络攻击入口更多。</li>
</ol>
<p>第6章 内容安全基础</p>
<ol>
<li>什么是信息内容安全？<br>–是研究利用计算机从包含海量信息并且迅速变化的网络中对特定安全主题相关信息进行自动获取，识别和分析的技术</li>
<li>了解常见的网络信息内容安全威胁。<br>–网络违法犯罪案件（利用煽动群众）<br>–网络违法信息<br>–网络不良信息</li>
</ol>
<p>第7章 网络空间安全法律法规</p>
<ol>
<li>了解《网络安全法》、《密码法》、《数据安全法》和《个人信息保护法》出台的先后顺序。<br>–就是这个序</li>
<li>对上述法律有最基本的了解：<br>① 《中华人民共和国国家安全法》明确提出了“网络空间主权”，表明了网络空间安全的重要性。《网络安全法》是2015年7月1日颁布施行的《国家安全法》在网络空间上的具体化。<br>② 《密码法》旨在规范密码应用和管理。<br>③ 《数据安全法》旨在规范数据处理活动，保障数据安全，促进数据开发利用。<br>④ 《中华人民共和国个人信息保护法》是为了保护个人信息权益，规范个人信息处理活动。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>洛谷题解</title>
    <url>/2023/04/25/%E6%B4%9B%E8%B0%B7/</url>
    <content><![CDATA[<h2 id="P2089-烤鸡"><a href="#P2089-烤鸡" class="headerlink" title="P2089 烤鸡"></a>P2089 烤鸡</h2><p>考点：深搜 剪枝 回溯（记录路径） </p>
<span id="more"></span>  


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> 	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,ans,a[<span class="number">12</span>],aa[<span class="number">10007</span>][<span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	aa[n][i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sum, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sum == n &amp;&amp; pos == <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">	ans++;</span><br><span class="line">	<span class="built_in">save</span>(ans);<span class="comment">//正确：存答案</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sum &gt;= n) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="number">10</span>) <span class="keyword">return</span>;</span><br><span class="line">a[pos] = <span class="number">1</span>;<span class="comment">//记录路径数组</span></span><br><span class="line"><span class="built_in">dfs</span>(sum + <span class="number">1</span>, pos+<span class="number">1</span>);</span><br><span class="line">a[pos] = <span class="number">2</span>;<span class="comment">//回溯</span></span><br><span class="line"><span class="built_in">dfs</span>(sum + <span class="number">2</span>, pos+<span class="number">1</span>);</span><br><span class="line">a[pos] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">dfs</span>(sum + <span class="number">3</span>, pos+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=ans; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		cout &lt;&lt; aa[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P1618-三连击"><a href="#P1618-三连击" class="headerlink" title="P1618 三连击"></a>P1618 三连击</h2><p>深搜&#x2F;枚举每个成比例的三位数判重</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> k,b,c,f;</span><br><span class="line"><span class="type">int</span> used[<span class="number">11</span>],a[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tonum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>*n<span class="number">-2</span>;i&lt;=<span class="number">3</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum*=<span class="number">10</span>;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">10</span>&amp;&amp;<span class="built_in">tonum</span>(<span class="number">1</span>)*b==<span class="built_in">tonum</span>(<span class="number">2</span>)*k&amp;&amp;<span class="built_in">tonum</span>(<span class="number">2</span>)*c==<span class="built_in">tonum</span>(<span class="number">3</span>)*b)</span><br><span class="line">    &#123;cout&lt;&lt;<span class="built_in">tonum</span>(<span class="number">1</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">tonum</span>(<span class="number">2</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">tonum</span>(<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">        f=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(!used[i])</span><br><span class="line">            &#123;</span><br><span class="line">                used[i]=<span class="number">1</span>;</span><br><span class="line">                a[n]=i;</span><br><span class="line">                <span class="built_in">dfs</span>(n+<span class="number">1</span>);</span><br><span class="line">                used[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!f)cout&lt;&lt;<span class="string">&quot;No!!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">## UVA816  bfs迷宫</span><br><span class="line">code:  </span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> stap1, stap2, goal1, goal2;</span><br><span class="line"><span class="type">char</span> fx;</span><br><span class="line"><span class="type">int</span> has_e[<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">10</span>][<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, y, dir;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> dir) :<span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">dir</span>(dir) &#123;&#125;</span><br><span class="line">	<span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node p[<span class="number">10</span>][<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> dr[] = &#123; <span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;;<span class="comment">//对应NESW</span></span><br><span class="line"><span class="type">int</span> dc[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* dirs = <span class="string">&quot;NESW&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* turns = <span class="string">&quot;FLR&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dir_id</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">strchr</span>(dirs, ch) - dirs; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">turn_id</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">strchr</span>(turns, c) - turns; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; name;</span><br><span class="line">	<span class="keyword">if</span> (name == <span class="string">&quot;END&quot;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	cin &gt;&gt; stap1 &gt;&gt; stap2 &gt;&gt; fx &gt;&gt; goal1 &gt;&gt; goal2;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>, y=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; x &amp;&amp; x)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; y;</span><br><span class="line">		string s;</span><br><span class="line">		<span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s != <span class="string">&quot;*&quot;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">			has_e[x][y][<span class="built_in">dir_id</span>(s[<span class="number">0</span>])][<span class="built_in">turn_id</span>(s[i])]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	has_e[stap1][stap2][<span class="built_in">dir_id</span>(fx)][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">walk</span><span class="params">(<span class="type">const</span> Node&amp; u, <span class="type">int</span> turn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dir = u.dir;</span><br><span class="line">	<span class="keyword">if</span> (turn == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dir = (dir + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (turn == <span class="number">2</span>)dir = (dir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Node</span>(u.x+dr[dir], u.y+dc[dir], dir);<span class="comment">//往某个方向走的下一格和朝向</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_ans</span><span class="params">(Node&amp; u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Node&gt;nodes;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		nodes.<span class="built_in">push_back</span>(u);</span><br><span class="line">		<span class="keyword">if</span> (d[u.x][u.y][u.dir] == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		u = p[u.x][u.y][u.dir];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//nodes.push_back(Node(stap1, stap2, dir_id(fx)));</span></span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = nodes.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (cnt % <span class="number">10</span> == <span class="number">0</span>)cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; (%d,%d)&quot;</span>, nodes[i].x, nodes[i].y);</span><br><span class="line">		<span class="keyword">if</span> (++cnt % <span class="number">10</span> == <span class="number">0</span>)cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nodes.<span class="built_in">size</span>() % <span class="number">10</span> != <span class="number">0</span>)cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;Node&gt;q;</span><br><span class="line">	<span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">	<span class="function">Node <span class="title">u</span><span class="params">(stap1, stap2, dir_id(fx))</span></span>;</span><br><span class="line">	d[u.x][u.y][u.dir] = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(u);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		Node u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (u.x == goal1 &amp;&amp; u.y == goal2) &#123; <span class="built_in">print_ans</span>(u); <span class="keyword">return</span>; &#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//三个方向都试试看能不能走</span></span><br><span class="line">			Node v = <span class="built_in">walk</span>(u, i);</span><br><span class="line">			<span class="keyword">if</span> (has_e[u.x][u.y][u.dir][i] &amp;&amp; v.x &gt;= <span class="number">0</span> &amp;&amp; v.x &lt;= <span class="number">9</span> &amp;&amp; v.y &gt;= <span class="number">0</span> &amp;&amp; v.y &lt;= <span class="number">9</span> &amp;&amp; d[v.x][v.y][v.dir] &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				d[v.x][v.y][v.dir] = d[u.x][u.y][u.dir] + <span class="number">1</span>;</span><br><span class="line">				p[v.x][v.y][v.dir] = u;</span><br><span class="line">				q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;  No Solution Possible&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">read</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">bfs</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">蒟蒻照着竞赛书写的首个<span class="number">100</span>行以上代码，本程序的最妙之处是位移函数和方向绑定。两套表示方向的体系NEWS是总方向，FLR是具体到每个节点能走的方向。根据人到达这个节点的朝向结合FLR枚举可以去的朝向（NEWS），此时注意朝向编号与位移编号对应。再根据图来筛选。基于此做BFS  </span><br><span class="line">## UVA10305 拓扑排序</span><br><span class="line">ac code:  </span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">int</span> map[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> n, m, a, b,t;</span><br><span class="line"><span class="type">int</span> u[<span class="number">200</span>],topo[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u[pos] = <span class="number">-1</span>;<span class="comment">//正在用</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (map[pos][i] &amp;&amp; !u[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (u[i] &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//检测环路</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!u[i])<span class="built_in">dfs</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	topo[--t] = pos;</span><br><span class="line">	u[pos] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123;</span><br><span class="line">		t = n;</span><br><span class="line">		<span class="built_in">memset</span>(map, <span class="number">0</span>, <span class="built_in">sizeof</span>(map));</span><br><span class="line">		<span class="built_in">memset</span>(u, <span class="number">0</span>, <span class="built_in">sizeof</span>(u));</span><br><span class="line">		<span class="built_in">memset</span>(topo, <span class="number">0</span>, <span class="built_in">sizeof</span>(topo));</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			map[a][b] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!u[i])<span class="built_in">dfs</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			cout &lt;&lt; topo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拓扑排序思路：两个数组一个放排完序列一个表示是否走过。一张图<br>dfs不断深搜找到最深节点，从后往前倒着放入目标数组。正着看就是目标排列了~~~<br>三种状态0，-1，1表示没用过，正在用，已用。便于检测环路。每次dfs先切换当前节点状态，for循环向下递归的时候检测下个节点状态。  </p>
<h2 id="无序字母对"><a href="#无序字母对" class="headerlink" title="无序字母对"></a>无序字母对</h2><p>ac code：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> map[<span class="number">150</span>][<span class="number">150</span>],vis[<span class="number">150</span>][<span class="number">150</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">60</span>],degree[<span class="number">60</span>],c[<span class="number">100009</span>];</span><br><span class="line"><span class="type">int</span> n,k=<span class="number">128</span>,tot;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; <span class="number">60</span>; v++)<span class="comment">//从小到大让每一步递归最小</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (map[u][v] &amp;&amp; !vis[u][v]) &#123;</span><br><span class="line">			vis[u][v] = vis[v][u] = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(v);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c[tot++] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		map[s[<span class="number">0</span>]-<span class="string">&#x27;A&#x27;</span>][s[<span class="number">1</span>]-<span class="string">&#x27;A&#x27;</span>] = map[s[<span class="number">1</span>]-<span class="string">&#x27;A&#x27;</span>][s[<span class="number">0</span>]-<span class="string">&#x27;A&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">		degree[s[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">		degree[s[<span class="number">1</span>] - <span class="string">&#x27;A&#x27;</span>] ++;</span><br><span class="line">		k = <span class="built_in">min</span>(k, <span class="built_in">min</span>((<span class="type">int</span> )s[<span class="number">0</span>], (<span class="type">int</span> )s[<span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (degree[i] &amp; <span class="number">1</span>)</span><br><span class="line">			a[++a[<span class="number">0</span>]]= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!a[<span class="number">0</span>])<span class="built_in">dfs</span>(k-<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="number">2</span>)<span class="built_in">dfs</span>(a[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl; <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=tot<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	cout &lt;&lt; (<span class="type">char</span>)(c[i]+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有很多小细节，比如 n的体量可以算出。字符型存储浪费空间。<code>-&#39;A&#39;</code>来压缩一下。其中a数组用法最巧妙。遍历一遍既统计了奇点的个数（a[0]）中。又把他们按大小顺序存在了数组里<br>欧拉路径的精髓是度数的判断。一旦判断了能形成欧拉通路之后就只需要dfs就好了  </p>
<h2 id="P1308-字符串题"><a href="#P1308-字符串题" class="headerlink" title="P1308 字符串题"></a>P1308 字符串题</h2><p>很离谱，这题一开始轻敌了，写了半天都wa，后来看了题解，好家伙大家都搁那发挥呢，一道水题有写指针移动的有写字典树的，没一个30行以内的……so本人不才就来开这个先河吧……<br>ac code：  </p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;sstream&gt;
#include&lt;cctype&gt;
#define inf 0x3f3f3f3f
using namespace std;
int ans=inf,c=0,ans2=0;
int main()&#123;
    string a,b,cc;
    cin&gt;&gt;a;
    getchar();
    getline(cin,cc);
    for(int i=0;i&lt;a.size();i++)//处理a
        a[i]=tolower(a[i]);
    string k=&quot; &quot;+a+&quot; &quot;;
    for(int i=0;i&lt;cc.size();i++)//处理cc
        cc[i]=tolower(cc[i]);
    stringstream ss(cc);
    cc=&quot; &quot;+cc+&quot; &quot;;
    ans=cc.find(k)+1;//在cc里找处理后的a
    while(ss&gt;&gt;b)&#123;
        if(a==b)&#123;
            ans2++;
        &#125;c++;
    &#125;
    if(ans!=0)
    cout&lt;&lt;ans2&lt;&lt;&quot; &quot;&lt;&lt;ans;
    else
        cout&lt;&lt;&quot;-1&quot;;
&#125;
</code></pre>
<p>29行ac的完美代码。其中有两处巧思</p>
<ol>
<li>用getline读入一整行（会读取行前空格）再注入b中，可避免写<code>while(cin&gt;&gt;b)</code>时不能调试的问题</li>
<li>在处理过的cc中直接用find找a不能确定找到的是单独的单词还是重合的一部分。我的解决方法是处理a，前后加上两个空格，找到后再把下标加一，ps找不到默认返回-1（npos），这个值可以改所以网上说法不一。<br>tolower和sstream不必多说，这题还是挺有技术含量的<br><img src="/../someimage/acp.png"></li>
</ol>
<h2 id="p5735-距离函数"><a href="#p5735-距离函数" class="headerlink" title="p5735 距离函数"></a>p5735 距离函数</h2><p>ac code:  </p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
double x1,x2,x3,y11,y2,y3,k;
double des(double x1,double y1,double x2,double y2)
&#123;
    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
&#125;
int main()
&#123;
    cin&gt;&gt;x1&gt;&gt;y11&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3;
    double a=des(x1,y11,x2,y2);
    double b=des(x1,y11,x3,y3);
    double c=des(x2,y2,x3,y3);
    k=a+b+c;
    printf(&quot;%.2lf&quot;,k);
&#125;
</code></pre>
<p>咱就是说不要用pow，会有误差，很怪。我一开始是pow套abs，有0.02的误差</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/11/%E7%A6%BB%E6%95%A3/</url>
    <content><![CDATA[<p>二部图：<br>简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界<br>哈斯图：<br>上界：（界外）盖住全范围的x及盖住x的<br>上确界：x<br>下界<br>下确界<br>极大元：不被盖住<br>最大元：盖住所有<br>极小元：不盖住任意<br>最小元：万物原点<br>矩阵的传递性：m*m是m的子集<br>图长度为x的路径数量：A^x所有元素和，回路数：主对角线元素和</p>
]]></content>
  </entry>
  <entry>
    <title>组合数学</title>
    <url>/2023/11/18/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<h2 id="大二上的起岸希决定开始研究数论方面"><a href="#大二上的起岸希决定开始研究数论方面" class="headerlink" title="大二上的起岸希决定开始研究数论方面"></a>大二上的起岸希决定开始研究数论方面</h2><hr>
<h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h3><p>康托展开可以用来求一个 1~n 的任意排列的排名<br>复杂度：O(n2)</p>
<span id="more"></span>  
<p>我们知道长为 5 的排列 [2,5,3,4,1] 大于以 1 为第一位的任何排列，以 1 为第一位的 5 的排列有 4! 种。这是非常好理解的。但是我们对第二位的 5 而言，它大于 第一位与这个排列相同的，而这一位比 5 小的 所有排列。不过我们要注意的是，这一位不仅要比 5 小，还要满足没有在当前排列的前面出现过，不然统计就重复了。因此这一位为 1,3 或 4，第一位为 2 的所有排列都比它要小，数量为 3*3!。<br><img src="/../someimage/image-10.png" alt="公式："><br>an要自己算。小于当前i且与前面都不重复的数的个数<br><img src="/../someimage/image-11.png" alt="Alt text"></p>
<h3 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h3><p>因为排列的排名和排列是一一对应的，所以康托展开满足双射关系，是可逆的。可以通过类似上面的过程倒推回来。<br>例如n&#x3D;5，因为 4! 是严格大于 3* 3!+2* 2!+1* 1! 的，所以可以认为对于长度为 5 的排列，排名 x 除以 4! 向下取整就是有几个数小于这个排列的第一位。则第一位为该数+1。</p>
<h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>求n个集合并集。<br><img src="/../someimage/image-12.png" alt="Alt text">先拆内层求和，再拆外层<br><img src="/../someimage/image-13.png" alt="Alt text">注意每个求和符号表四很多项  </p>
<hr>
<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="同余定理"><a href="#同余定理" class="headerlink" title="同余定理"></a>同余定理</h3><p><img src="/../someimage/image-14.png" alt="Alt text"><br>解同余方程：<br><img src="/../someimage/image-19.png" alt="Alt text"><br>解不定方程：扩展欧几里得（exgcd）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) &#123; x0 = <span class="number">1</span>; g = a; <span class="keyword">return</span>; &#125;<span class="comment">//顺便求gcd</span></span><br><span class="line">	<span class="built_in">exgcd</span>(b, a % b);</span><br><span class="line">	tmp = x0; x0 = y0; y0 = tmp - a / b * y0;<span class="comment">//x0,y0最后的值对应式中的一组解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/../someimage/image-22.png" alt="Alt text"><br>通解（这里的k相当于x）：<br><img src="/../someimage/image-21.png" alt="Alt text"><br><img src="/../someimage/image-20.png" alt="Alt text"></p>
<h3 id="次方求模"><a href="#次方求模" class="headerlink" title="次方求模"></a>次方求模</h3><p>当幂次足够大时（如a的10^18次幂），使用二分求幂（快速幂）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">binarypow</span><span class="params">(LL a,LL b,LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">binarypow</span>(a,b<span class="number">-1</span>,m)*a;<span class="comment">//奇数分开一个a</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">binarypow</span>(a,b/<span class="number">2</span>,m)*<span class="built_in">binarypow</span>(a,b/<span class="number">2</span>+<span class="number">1</span>,m);<span class="comment">//偶数，对半砍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取模：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">binarypow</span><span class="params">(LL a,LL b,LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">binarypow</span>(a,b<span class="number">-1</span>,m)*a%m;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">binarypow</span>(a,b/<span class="number">2</span>,m)*<span class="built_in">binarypow</span>(a,b/<span class="number">2</span>+<span class="number">1</span>,m)%m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
